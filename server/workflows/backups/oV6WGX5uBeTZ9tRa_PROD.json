{
  "updatedAt": "2026-01-31T22:24:51.612Z",
  "createdAt": "2026-01-25T09:36:24.234Z",
  "id": "oV6WGX5uBeTZ9tRa",
  "name": "[EFD] European Football Daily",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "european-football-daily",
        "responseMode": "onReceived",
        "options": {}
      },
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        0,
        208
      ],
      "id": "0025e044-d2ba-4e9f-8e73-98ca642c1087",
      "webhookId": "191adfc0-b71a-41c2-8a26-25ca9ec0b6c1"
    },
    {
      "parameters": {
        "url": "https://news.google.com/rss/search?q=european+football+champions+league+OR+premier+league+OR+la+liga+OR+bundesliga+OR+serie+a&hl=en-US&gl=US&ceid=US:en",
        "options": {}
      },
      "name": "Fetch RSS",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        512,
        112
      ],
      "id": "a0c4d441-f13a-4003-8f49-1a710d29c12e"
    },
    {
      "parameters": {
        "options": {}
      },
      "name": "Parse XML",
      "type": "n8n-nodes-base.xml",
      "typeVersion": 1,
      "position": [
        752,
        112
      ],
      "id": "9466c9e8-2426-4e44-8a8e-ef37a1138c38"
    },
    {
      "parameters": {
        "jsCode": "const rss = $input.first().json;\nconst webhookData = $('Webhook').first().json.body || {};\nconst recentTopics = webhookData.recentTopics || [];\n\n// Build normalized headline set for exact matching\nconst recentHeadlinesNormalized = new Set(\n  recentTopics.map(t => t.headline.toLowerCase().trim().replace(/[^a-z0-9\\s]/g, ''))\n);\n\nconst items = rss?.rss?.channel?.item || [];\n\nconst articles = items.slice(0, 20).map(item => ({\n  title: item.title || '',\n  sourceHeadline: item.title || '', // Preserve original for callback\n  link: item.link || '',\n  source: 'Google News',\n  pubDate: item.pubDate || ''\n})).filter(a => {\n  const normalizedTitle = a.title.toLowerCase().trim().replace(/[^a-z0-9\\s]/g, '');\n  \n  // PRIMARY: Normalized exact headline match\n  if (recentHeadlinesNormalized.has(normalizedTitle)) {\n    return false;\n  }\n  \n  // SECONDARY: Word overlap check (>50% = likely duplicate)\n  const words = new Set(normalizedTitle.split(/\\s+/).filter(w => w.length > 3));\n  if (words.size >= 3) {\n    for (const recent of recentTopics) {\n      const recentNorm = recent.headline.toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n      const recentWords = new Set(recentNorm.split(/\\s+/).filter(w => w.length > 3));\n      if (recentWords.size >= 3) {\n        const overlap = [...words].filter(w => recentWords.has(w)).length;\n        const similarity = overlap / Math.min(words.size, recentWords.size);\n        if (similarity > 0.5) {\n          return false;\n        }\n      }\n    }\n  }\n  \n  return true;\n}).slice(0, 10);\n\n// Fallback if all filtered out\nif (articles.length === 0 && items.length > 0) {\n  const first = items[0];\n  return [{\n    json: {\n      title: first.title || 'European Football Update',\n      sourceHeadline: first.title || 'European Football Update',\n      link: first.link || '',\n      source: 'Google News',\n      pubDate: first.pubDate || '',\n      forcedFallback: true,\n      recentTopicsCount: recentTopics.length\n    }\n  }];\n}\n\nreturn articles.map(a => ({ json: { ...a, recentTopicsCount: recentTopics.length } }));"
      },
      "name": "Extract Articles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        112
      ],
      "id": "2a98ef6a-8bc2-4312-9ae1-9c72f99e4b84"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"extract-articles\",\n  \"stepIndex\": 1,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"articles\": {{ JSON.stringify($input.all().map(i => i.json)) }},\n    \"count\": {{ $input.all().length }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
        "options": {}
      },
      "name": "Callback Articles",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1104,
        256
      ],
      "id": "c6ed77f1-fb89-4efe-875f-2c7668fa7140"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $input.first().json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are a European football social media manager. Create an informative Facebook post.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\nHAS SCORE: {{ $json.selectedTopic.hasScore || false }}\\nHASHTAGS TO USE: {{ $json.hashtagString }}\\n\\nCreate an informative Facebook post (2-3 short paragraphs) that:\\n1. Leads with the key facts - scores, numbers, team names\\n2. Provides context about what this means for the league/tournament\\n3. Ends with a question to drive engagement\\n4. MUST end with these EXACT hashtags: {{ $json.hashtagString }}\\n\\nStyle guidelines:\\n- Be factual and informative, not sensational\\n- Highlight scores, statistics, and numbers prominently\\n- Mention team and league names for brand recognition\\n- Do NOT mention specific player or coach names\\n- Keep tone professional but accessible\\n\\nReturn ONLY a JSON object with postContent (the text including hashtags) and sentiment (positive/neutral/negative)\"\n    }]\n  }]\n}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "name": "Generate Post",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2816,
        -32
      ],
      "id": "7c494835-fa77-48c9-ae73-269be50bb6af",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Aggregate Compliant Topics\").first().json;\nconst hashtagData = $(\"Parse Hashtags\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const post = JSON.parse(cleaned);\n  return [{\n    json: {\n      postContent: post.postContent,\n      sentiment: post.sentiment || \"positive\",\n      safeImagePrompt: prevData.selectedTopic.safeImagePrompt,\n      anonymizedDescriptions: prevData.selectedTopic.anonymizedDescriptions || hashtagData.anonymizedDescriptions || {},\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.selectedTopic?.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      postContent: \"Football news update! Exciting developments in European football today.\",\n      sentiment: \"positive\",\n      safeImagePrompt: prevData.selectedTopic?.safeImagePrompt || \"Exciting football stadium scene with cheering fans\",\n      anonymizedDescriptions: prevData.selectedTopic?.anonymizedDescriptions || {},\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.selectedTopic?.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Post",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        112
      ],
      "id": "5ffc1c44-ad8f-4df3-bb2c-2ac5ec931d9f"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $input.first().json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "fb8ce752-bb66-4d73-abb2-24fad043a177",
      "name": "Generate Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2256,
        112
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Post\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const imageData = JSON.parse(cleaned);\n  return [{\n    json: {\n      imagePrompt: imageData.imagePrompt,\n      style: imageData.style || \"photorealistic\",\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      imagePrompt: \"Exciting football celebration scene in a modern stadium\",\n      style: \"photorealistic\",\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Image Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2512,
        112
      ],
      "id": "654ab797-28bc-4e88-a66c-74887fbedae5"
    },
    {
      "parameters": {
        "jsCode": "const brandingResult = $input.first().json;\nconst prevData = $(\"Parse Imagen Response\").first().json;\nconst aggregateData = $(\"Aggregate Compliant Topics\").first().json;\n\nconst postContent = prevData.postContent || \"Football news update!\";\nconst imagePrompt = prevData.imagePrompt || \"European football celebration\";\nconst sourceLink = prevData.sourceLink || \"\";\n\n// Get the selected topic from aggregation step (includes sourceHeadline)\nconst selectedTopic = aggregateData.selectedTopic || {};\n\n// Use branded image if available, otherwise fallback to original\nlet imageDataUri = prevData.imageDataUri || null;\nif (brandingResult.success && brandingResult.brandedImageBase64) {\n  imageDataUri = \"data:image/png;base64,\" + brandingResult.brandedImageBase64;\n}\n\n// Create transparency/disclosure post\nlet transparencyPost = \"I've developed this AI-driven system to efficiently curate European football news, serving as a professional 'proof of work' for AI integration. Grounded in transparency and the human-in-the-loop principle, this project demonstrates how AI can enhance specialized content. Follow for updates, or visit my bio to learn how to build similar systems.\\n\\nBilko Bibitkov Human-Centric AI Curation\";\n\nif (sourceLink) {\n  transparencyPost += \"\\n\\nSource: \" + sourceLink;\n}\n\nconst output = {\n  success: true,\n  selectedTopic: {\n    headline: selectedTopic.headline || \"\",\n    sourceHeadline: selectedTopic.sourceHeadline || selectedTopic.headline || \"\",\n    sourceHeadlineHash: selectedTopic.sourceHeadlineHash || \"\",\n    teams: selectedTopic.teams || [],\n    event: selectedTopic.event || \"\",\n    dataRichness: selectedTopic.dataRichness || 0,\n    brandValue: selectedTopic.brandValue || 0\n  },\n  data: {\n    postContent: postContent,\n    imagePrompt: imagePrompt,\n    imageUrl: imageDataUri,\n    transparencyPost: transparencyPost,\n    sourceLink: sourceLink,\n    contentFiltered: !imageDataUri,\n    brandingApplied: brandingResult.success === true\n  },\n  metadata: {\n    workflowId: \"european-football-daily\",\n    executedAt: new Date().toISOString(),\n    aiGenerated: true\n  }\n};\nreturn [{ json: output }];"
      },
      "name": "Build Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        112
      ],
      "id": "71b64e2c-1852-4ef6-a21d-732907892df3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"final-output\",\n  \"stepIndex\": 3,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {{ JSON.stringify($input.first().json) }},\n  \"executionId\": \"{{ $execution.id }}\"\n}",
        "options": {}
      },
      "name": "Callback Final",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3008,
        112
      ],
      "id": "5a99a7c6-1f47-47eb-a13d-888ae0334bcf"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $('Build Final Output').first().json }}",
        "options": {}
      },
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        3264,
        208
      ],
      "id": "4ea89a64-7267-4476-aac6-d67c10a7da98"
    },
    {
      "parameters": {
        "content": "PRODUCTION"
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        416,
        496
      ],
      "id": "303bff0e-4feb-4c29-903e-cd2782ab38ba",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"{{ $json.imagePrompt }}. Include bold stylized text overlay on the image saying: {{ $json.tagline }}\"\n    }]\n  }],\n  \"generation_config\": {\n    \"response_modalities\": [\"IMAGE\"],\n    \"image_config\": {\n      \"aspect_ratio\": \"1:1\"\n    }\n  }\n}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "74affa50-0102-49a6-8190-3e24f1ec0a2e",
      "name": "Call Imagen API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3104,
        112
      ],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Tagline\").first().json;\n\n// Get image from Nano Banana Pro response format\nconst parts = input?.candidates?.[0]?.content?.parts || [];\nconst imagePart = parts.find(p => p.inlineData?.mimeType?.startsWith(\"image/\"));\n\nif (imagePart && imagePart.inlineData?.data) {\n  const mimeType = imagePart.inlineData.mimeType;\n  const base64Data = imagePart.inlineData.data;\n  const imageDataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n\n  return [{\n    json: {\n      imageDataUri: imageDataUri,\n      imagePrompt: prevData.imagePrompt,\n      tagline: prevData.tagline,\n      postContent: prevData.postContent,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} else {\n  // Fallback when image generation fails\n  return [{\n    json: {\n      imageDataUri: null,\n      imagePrompt: prevData.imagePrompt,\n      tagline: prevData.tagline,\n      postContent: prevData.postContent,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      imagenError: \"No image data in response\"\n    }\n  }];\n}"
      },
      "id": "ec694419-9c45-4f5d-b2a9-56f136492315",
      "name": "Parse Imagen Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3360,
        112
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Analyze this football news headline and extract key information for social media.\\n\\nHEADLINE: {{ $json.title }}\\n\\nReturn ONLY a JSON object with:\\n- headline: the original headline\\n- teams: array of team names mentioned (prioritize big clubs: Real Madrid, Barcelona, Man City, Liverpool, Bayern, PSG, Juventus, etc.)\\n- event: brief description (match result, transfer, injury, etc.)\\n- hasScore: boolean - true if headline contains a match score like 3-0, 2-1\\n- hasNumbers: boolean - true if contains significant numbers (transfer fees, goals, points, positions)\\n- dataRichness: score 1-10 (10=has scores/stats/numbers, 5=has team names, 1=vague/generic)\\n- brandValue: score 1-10 (10=mentions top clubs/leagues/tournaments, 1=unknown teams)\\n- imageability: score 1-10 how easy to create a generic image\\n- imageSuggestion: a generic image concept avoiding real people names\\n\\nPrioritize headlines with: actual scores, transfer fees, league standings, big club names.\\nExample: { \\\"headline\\\": \\\"Barcelona 3-0 Real Madrid\\\", \\\"teams\\\": [\\\"Barcelona\\\", \\\"Real Madrid\\\"], \\\"event\\\": \\\"El Clasico victory\\\", \\\"hasScore\\\": true, \\\"hasNumbers\\\": true, \\\"dataRichness\\\": 10, \\\"brandValue\\\": 10, \\\"imageability\\\": 9, \\\"imageSuggestion\\\": \\\"celebrating football team in red and blue\\\" }\"\n    }]\n  }]\n}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 2000
            }
          }
        },
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "3bcffc23-1424-49a1-afd7-7f0514ed2ef7",
      "name": "Topic Analyst",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1312,
        -32
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst geminiApiKey = $(\"Webhook\").first().json.body.geminiApiKey;\nconst callbackUrl = $(\"Webhook\").first().json.body.callbackUrl;\n\n// Get the source article data from Extract Articles using item index\nconst articleItems = $(\"Extract Articles\").all();\nconst currentIndex = $runIndex;\nconst articleData = articleItems[currentIndex]?.json || {};\nconst sourceLink = articleData.link || \"\";\nconst sourceHeadline = articleData.sourceHeadline || articleData.title || \"\";\nconst sourceHeadlineHash = articleData.titleHash || \"\";\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const analysis = JSON.parse(cleaned);\n  return [{\n    json: {\n      ...analysis,\n      sourceLink: sourceLink,\n      sourceHeadline: sourceHeadline,\n      sourceHeadlineHash: sourceHeadlineHash,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      headline: \"Football news update\",\n      people: [],\n      teams: [],\n      event: \"general news\",\n      imageability: 5,\n      imageSuggestion: \"generic football stadium scene\",\n      sourceLink: sourceLink,\n      sourceHeadline: sourceHeadline,\n      sourceHeadlineHash: sourceHeadlineHash,\n      parseError: e.message,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}"
      },
      "id": "4a292d0b-d120-4074-87fc-6667de4e4de6",
      "name": "Parse Topic Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        -32
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 2000
            }
          }
        },
        "contentType": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "9c51724e-f9eb-4bea-a72c-3dbf6c163d0a",
      "name": "Compliance Checker",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1920,
        -32
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Topic Analysis\").first().json;\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const compliance = JSON.parse(cleaned);\n  return [{\n    json: {\n      headline: prevData.headline,\n      people: prevData.people,\n      teams: prevData.teams,\n      event: prevData.event,\n      imageability: prevData.imageability,\n      imageSuggestion: prevData.imageSuggestion,\n      sourceLink: prevData.sourceLink,\n      sourceHeadline: prevData.sourceHeadline,\n      sourceHeadlineHash: prevData.sourceHeadlineHash,\n      compliant: compliance.compliant !== false,\n      complianceReason: compliance.reason,\n      anonymizedDescriptions: compliance.anonymizedDescriptions || {},\n      safeImagePrompt: compliance.safeImagePrompt,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ...prevData,\n      compliant: true,\n      complianceReason: \"Parse error, using fallback: \" + e.message,\n      anonymizedDescriptions: {},\n      safeImagePrompt: \"Generic football stadium celebration scene with fans cheering\"\n    }\n  }];\n}"
      },
      "id": "e2dd7a80-e193-4290-a91b-542eb7f02b52",
      "name": "Parse Compliance Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2208,
        -32
      ]
    },
    {
      "parameters": {
        "jsCode": "// Collect all items (each article's compliance check result)\nconst items = $input.all();\nconst geminiApiKey = items[0]?.json?.geminiApiKey;\nconst callbackUrl = items[0]?.json?.callbackUrl;\n\n// Filter to only compliant topics and sort by data-richness + brand value\nconst compliantTopics = items\n  .map(item => item.json)\n  .filter(topic => topic.compliant === true)\n  .sort((a, b) => {\n    // Combined score prioritizing data-rich, high-brand topics\n    const scoreA = (a.dataRichness || 0) * 2 + (a.brandValue || 0) * 1.5 + (a.imageability || 0);\n    const scoreB = (b.dataRichness || 0) * 2 + (b.brandValue || 0) * 1.5 + (b.imageability || 0);\n    return scoreB - scoreA;\n  });\n\n// If no compliant topics, create a safe fallback\nif (compliantTopics.length === 0) {\n  return [{\n    json: {\n      selectedTopic: {\n        headline: 'European Football Weekly Update',\n        teams: [],\n        event: 'weekly roundup',\n        safeImagePrompt: 'Exciting football match scene in a packed stadium with cheering fans',\n        anonymizedDescriptions: {},\n        fallback: true\n      },\n      allTopics: items.map(i => i.json),\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}\n\n// Select the best topic (highest combined score)\nreturn [{\n  json: {\n    selectedTopic: compliantTopics[0],\n    alternativeTopics: compliantTopics.slice(1, 3),\n    allTopics: items.map(i => i.json),\n    geminiApiKey,\n    callbackUrl\n  }\n}];"
      },
      "id": "2426cf99-5a5b-4963-9ffc-81c4ec3cee01",
      "name": "Aggregate Compliant Topics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2512,
        -32
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Find the 3 most relevant, high-reach hashtags for this European football topic.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\n\\nRules:\\n- Return EXACTLY 3 hashtags\\n- Must be real, widely-used hashtags on social media\\n- Must be directly relevant to this specific topic/teams/event\\n- Include the # symbol\\n- Prefer hashtags with high engagement (millions of posts)\\n\\nReturn ONLY a JSON object: {\\\"hashtags\\\": [\\\"#tag1\\\", \\\"#tag2\\\", \\\"#tag3\\\"]}\"\n    }]\n  }]\n}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "hashtag-researcher-1769380010487",
      "name": "Hashtag Researcher",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        2816,
        -32
      ],
      "typeVersion": 4.2,
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get Gemini response from HTTP Request\nconst geminiResponse = $input.first().json;\n\n// Get original data from Aggregate Compliant Topics (2 nodes back)\nconst originalData = $(\"Aggregate Compliant Topics\").first().json;\nconst geminiApiKey = originalData.geminiApiKey;\nconst callbackUrl = originalData.callbackUrl;\nconst selectedTopic = originalData.selectedTopic;\n\n// Parse hashtags from Gemini response\nlet hashtags = [\"#football\", \"#soccer\", \"#UEFA\"]; // fallback\ntry {\n  const candidates = geminiResponse.candidates || [];\n  if (candidates.length > 0) {\n    let text = candidates[0].content?.parts?.[0]?.text || \"\";\n    text = text.replace(/```json\\n?/g, \"\").replace(/```/g, \"\").trim();\n    const parsed = JSON.parse(text);\n    if (parsed.hashtags && Array.isArray(parsed.hashtags)) {\n      hashtags = parsed.hashtags.slice(0, 3);\n    }\n  }\n} catch (e) {\n  // Keep fallback\n}\n\nreturn [{\n  json: {\n    selectedTopic: selectedTopic,\n    sourceLink: selectedTopic.sourceLink || \"\",\n    anonymizedDescriptions: selectedTopic.anonymizedDescriptions || {},\n    hashtags: hashtags,\n    hashtagString: hashtags.join(\" \"),\n    geminiApiKey: geminiApiKey,\n    callbackUrl: callbackUrl\n  }\n}];"
      },
      "id": "parse-hashtags-1769380010487",
      "name": "Parse Hashtags",
      "type": "n8n-nodes-base.code",
      "position": [
        3008,
        -32
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "BilkoBibitkovApp/1.0"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create an informative headline for a European football image.\\n\\nTOPIC: {{ $json.selectedTopic?.headline || \\\"Football news\\\" }}\\nTEAMS: {{ ($json.selectedTopic?.teams || []).join(' vs ') }}\\nEVENT: {{ $json.selectedTopic?.event || \\\"update\\\" }}\\nHAS SCORE: {{ $json.selectedTopic?.hasScore || false }}\\nHAS NUMBERS: {{ $json.selectedTopic?.hasNumbers || false }}\\n\\nRules:\\n- 3-6 words maximum\\n- If HAS SCORE is true, INCLUDE the actual score from the headline (e.g., \\\"Barcelona 3-0 Madrid\\\")\\n- If HAS NUMBERS is true, include the key number (transfer fee, points, goals)\\n- Prioritize team names and factual information\\n- NO generic phrases like \\\"Game On\\\", \\\"Breaking News\\\", \\\"Big Win\\\", \\\"What A Match\\\"\\n- Should inform the viewer of WHAT happened, not just generate excitement\\n\\nGood examples:\\n- \\\"Barcelona 3-0 Real Madrid\\\"\\n- \\\"Man City Clinches Title\\\"\\n- \\\"Â£80M Transfer Complete\\\"\\n- \\\"Liverpool Top After Win\\\"\\n\\nBad examples (DO NOT USE):\\n- \\\"Game On!\\\"\\n- \\\"What A Match!\\\"\\n- \\\"Football Fever\\\"\\n- \\\"Big News Today\\\"\\n\\nReturn ONLY a JSON object: {\\\"tagline\\\": \\\"your informative headline here\\\"}\"\n    }]\n  }]\n}",
        "options": {
          "response": {
            "response": {}
          }
        },
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "name": "Generate Tagline",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2608,
        112
      ],
      "id": "tagline-gen-1769390960853",
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Image Prompt\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const taglineData = JSON.parse(cleaned);\n  return [{\n    json: {\n      tagline: taglineData.tagline || \"Game On!\",\n      imagePrompt: prevData.imagePrompt,\n      style: prevData.style,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      tagline: \"Game On!\",\n      imagePrompt: prevData.imagePrompt,\n      style: prevData.style,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Tagline",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2864,
        112
      ],
      "id": "parse-tagline-1769390960853"
    },
    {
      "id": "brand-image-node-1769619318863",
      "name": "Brand Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3580,
        112
      ],
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/images/brand",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ imageBase64: $json.imageDataUri ? $json.imageDataUri.replace(/^data:image\\/[^;]+;base64,/, \"\") : null }) }}",
        "options": {}
      }
    },
    {
      "id": "parse-brand-node-1769619318863",
      "name": "Parse Brand Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3800,
        112
      ],
      "parameters": {
        "jsCode": "const brandingResponse = $input.first().json;\nconst prevData = $(\"Parse Imagen Response\").first().json;\n\n// Pass through branding response with original data\nreturn [{\n  json: {\n    // Branding response fields\n    success: brandingResponse.success === true,\n    brandedImageBase64: brandingResponse.brandedImageBase64 || null,\n    \n    // Original data from Parse Imagen Response\n    imageDataUri: prevData.imageDataUri,\n    imagePrompt: prevData.imagePrompt,\n    tagline: prevData.tagline,\n    postContent: prevData.postContent,\n    sourceLink: prevData.sourceLink || \"\",\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}];"
      }
    },
    {
      "id": "cc_body_builder",
      "name": "Build Compliance Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1620,
        -32
      ],
      "parameters": {
        "jsCode": "// Build the Gemini API request body for compliance checking\nconst headline = $input.first().json.headline;\nconst people = $input.first().json.people || [];\nconst imageSuggestion = $input.first().json.imageSuggestion;\nconst geminiApiKey = $input.first().json.geminiApiKey;\nconst runIndex = $input.first().json.runIndex;\nconst link = $input.first().json.link;\n\nconst prompt = `You are an AI image compliance expert. Analyze this football topic and create anonymous visual descriptions.\n\nTOPIC: ${headline}\nPEOPLE: ${JSON.stringify(people)}\nIMAGE IDEA: ${imageSuggestion}\n\nFor each person listed, generate an anonymous physical description (height, build, hair, attire) without using their name.\n\nReturn ONLY valid JSON with these fields:\n- compliant: true\n- reason: why its safe for image generation  \n- anonymizedDescriptions: object mapping each person name to their anonymous description\n- safeImagePrompt: the image prompt rewritten with anonymous descriptions`;\n\nreturn {\n  json: {\n    headline,\n    people,\n    imageSuggestion,\n    geminiApiKey,\n    runIndex,\n    link,\n    requestBody: {\n      contents: [{\n        parts: [{ text: prompt }]\n      }]\n    }\n  }\n};\n"
      }
    },
    {
      "id": "gi_body_builder",
      "name": "Build Image Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2006,
        112
      ],
      "parameters": {
        "jsCode": "// Build the Gemini API request body for image prompt generation\nconst item = $input.first().json;\nconst safeImagePrompt = item.safeImagePrompt || '';\nconst anonymizedDescriptions = item.anonymizedDescriptions || {};\nconst geminiApiKey = item.geminiApiKey;\n\nconst prompt = `Create an image prompt for AI image generation based on this concept: ${safeImagePrompt}. \nInclude any people descriptions: ${JSON.stringify(anonymizedDescriptions)}.\nCreate a detailed, cinematic prompt. Focus on action and atmosphere. NO real person names.\nReturn ONLY valid JSON with: imagePrompt (your detailed prompt), style (photorealistic)`;\n\nreturn {\n  json: {\n    ...item,\n    requestBody: {\n      contents: [{\n        parts: [{ text: prompt }]\n      }]\n    }\n  }\n};\n"
      }
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Fetch RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch RSS": {
      "main": [
        [
          {
            "node": "Parse XML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse XML": {
      "main": [
        [
          {
            "node": "Extract Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Articles": {
      "main": [
        [
          {
            "node": "Topic Analyst",
            "type": "main",
            "index": 0
          },
          {
            "node": "Callback Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Post": {
      "main": [
        [
          {
            "node": "Parse Post",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Image": {
      "main": [
        [
          {
            "node": "Parse Image Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Final Output": {
      "main": [
        [
          {
            "node": "Callback Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Callback Final": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Imagen API": {
      "main": [
        [
          {
            "node": "Parse Imagen Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Imagen Response": {
      "main": [
        [
          {
            "node": "Brand Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Topic Analyst": {
      "main": [
        [
          {
            "node": "Parse Topic Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Topic Analysis": {
      "main": [
        [
          {
            "node": "Build Compliance Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compliance Checker": {
      "main": [
        [
          {
            "node": "Parse Compliance Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Compliance Check": {
      "main": [
        [
          {
            "node": "Aggregate Compliant Topics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Compliant Topics": {
      "main": [
        [
          {
            "node": "Hashtag Researcher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Post": {
      "main": [
        [
          {
            "node": "Build Image Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Image Prompt": {
      "main": [
        [
          {
            "node": "Generate Tagline",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hashtag Researcher": {
      "main": [
        [
          {
            "node": "Parse Hashtags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Hashtags": {
      "main": [
        [
          {
            "node": "Generate Post",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Tagline": {
      "main": [
        [
          {
            "node": "Parse Tagline",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Tagline": {
      "main": [
        [
          {
            "node": "Call Imagen API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Brand Image": {
      "main": [
        [
          {
            "node": "Parse Brand Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Brand Response": {
      "main": [
        [
          {
            "node": "Build Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Compliance Request": {
      "main": [
        [
          {
            "node": "Compliance Checker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Image Request": {
      "main": [
        [
          {
            "node": "Generate Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "node:Schedule Trigger": {
      "recurrenceRules": []
    }
  },
  "meta": null,
  "pinData": {},
  "versionId": "922d2045-d278-4ab5-9d7d-fa05025eb58e",
  "activeVersionId": "922d2045-d278-4ab5-9d7d-fa05025eb58e",
  "versionCounter": 348,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-01-25T09:36:24.236Z",
      "createdAt": "2026-01-25T09:36:24.236Z",
      "role": "workflow:owner",
      "workflowId": "oV6WGX5uBeTZ9tRa",
      "projectId": "tYcTNrTV20x5m3NS",
      "project": {
        "updatedAt": "2026-01-21T18:01:18.310Z",
        "createdAt": "2026-01-21T18:01:12.176Z",
        "id": "tYcTNrTV20x5m3NS",
        "name": "Bilko Bibitkov <bilkobibitkov2000@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "80f5768f-36e3-4197-9886-2f8e29df41d7",
        "projectRelations": [
          {
            "updatedAt": "2026-01-21T18:01:12.176Z",
            "createdAt": "2026-01-21T18:01:12.176Z",
            "userId": "80f5768f-36e3-4197-9886-2f8e29df41d7",
            "projectId": "tYcTNrTV20x5m3NS",
            "user": {
              "updatedAt": "2026-01-31T08:03:32.000Z",
              "createdAt": "2026-01-21T18:01:09.996Z",
              "id": "80f5768f-36e3-4197-9886-2f8e29df41d7",
              "email": "bilkobibitkov2000@gmail.com",
              "firstName": "Bilko",
              "lastName": "Bibitkov",
              "personalizationAnswers": null,
              "settings": {
                "userActivated": true,
                "userClaimedAiCredits": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "d144QoAsV5hIbzvQ",
                "userActivatedAt": 1769150504302,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1769766178056
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-01-31",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-01-31T22:24:51.616Z",
    "createdAt": "2026-01-31T22:24:51.616Z",
    "versionId": "922d2045-d278-4ab5-9d7d-fa05025eb58e",
    "workflowId": "oV6WGX5uBeTZ9tRa",
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "european-football-daily",
          "responseMode": "onReceived",
          "options": {}
        },
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 1,
        "position": [
          0,
          208
        ],
        "id": "0025e044-d2ba-4e9f-8e73-98ca642c1087",
        "webhookId": "191adfc0-b71a-41c2-8a26-25ca9ec0b6c1"
      },
      {
        "parameters": {
          "url": "https://news.google.com/rss/search?q=european+football+champions+league+OR+premier+league+OR+la+liga+OR+bundesliga+OR+serie+a&hl=en-US&gl=US&ceid=US:en",
          "options": {}
        },
        "name": "Fetch RSS",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          512,
          112
        ],
        "id": "a0c4d441-f13a-4003-8f49-1a710d29c12e"
      },
      {
        "parameters": {
          "options": {}
        },
        "name": "Parse XML",
        "type": "n8n-nodes-base.xml",
        "typeVersion": 1,
        "position": [
          752,
          112
        ],
        "id": "9466c9e8-2426-4e44-8a8e-ef37a1138c38"
      },
      {
        "parameters": {
          "jsCode": "const rss = $input.first().json;\nconst webhookData = $('Webhook').first().json.body || {};\nconst recentTopics = webhookData.recentTopics || [];\n\n// Build normalized headline set for exact matching\nconst recentHeadlinesNormalized = new Set(\n  recentTopics.map(t => t.headline.toLowerCase().trim().replace(/[^a-z0-9\\s]/g, ''))\n);\n\nconst items = rss?.rss?.channel?.item || [];\n\nconst articles = items.slice(0, 20).map(item => ({\n  title: item.title || '',\n  sourceHeadline: item.title || '', // Preserve original for callback\n  link: item.link || '',\n  source: 'Google News',\n  pubDate: item.pubDate || ''\n})).filter(a => {\n  const normalizedTitle = a.title.toLowerCase().trim().replace(/[^a-z0-9\\s]/g, '');\n  \n  // PRIMARY: Normalized exact headline match\n  if (recentHeadlinesNormalized.has(normalizedTitle)) {\n    return false;\n  }\n  \n  // SECONDARY: Word overlap check (>50% = likely duplicate)\n  const words = new Set(normalizedTitle.split(/\\s+/).filter(w => w.length > 3));\n  if (words.size >= 3) {\n    for (const recent of recentTopics) {\n      const recentNorm = recent.headline.toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n      const recentWords = new Set(recentNorm.split(/\\s+/).filter(w => w.length > 3));\n      if (recentWords.size >= 3) {\n        const overlap = [...words].filter(w => recentWords.has(w)).length;\n        const similarity = overlap / Math.min(words.size, recentWords.size);\n        if (similarity > 0.5) {\n          return false;\n        }\n      }\n    }\n  }\n  \n  return true;\n}).slice(0, 10);\n\n// Fallback if all filtered out\nif (articles.length === 0 && items.length > 0) {\n  const first = items[0];\n  return [{\n    json: {\n      title: first.title || 'European Football Update',\n      sourceHeadline: first.title || 'European Football Update',\n      link: first.link || '',\n      source: 'Google News',\n      pubDate: first.pubDate || '',\n      forcedFallback: true,\n      recentTopicsCount: recentTopics.length\n    }\n  }];\n}\n\nreturn articles.map(a => ({ json: { ...a, recentTopicsCount: recentTopics.length } }));"
        },
        "name": "Extract Articles",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1008,
          112
        ],
        "id": "2a98ef6a-8bc2-4312-9ae1-9c72f99e4b84"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"extract-articles\",\n  \"stepIndex\": 1,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"articles\": {{ JSON.stringify($input.all().map(i => i.json)) }},\n    \"count\": {{ $input.all().length }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
          "options": {}
        },
        "name": "Callback Articles",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1104,
          256
        ],
        "id": "c6ed77f1-fb89-4efe-875f-2c7668fa7140"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $input.first().json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are a European football social media manager. Create an informative Facebook post.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\nHAS SCORE: {{ $json.selectedTopic.hasScore || false }}\\nHASHTAGS TO USE: {{ $json.hashtagString }}\\n\\nCreate an informative Facebook post (2-3 short paragraphs) that:\\n1. Leads with the key facts - scores, numbers, team names\\n2. Provides context about what this means for the league/tournament\\n3. Ends with a question to drive engagement\\n4. MUST end with these EXACT hashtags: {{ $json.hashtagString }}\\n\\nStyle guidelines:\\n- Be factual and informative, not sensational\\n- Highlight scores, statistics, and numbers prominently\\n- Mention team and league names for brand recognition\\n- Do NOT mention specific player or coach names\\n- Keep tone professional but accessible\\n\\nReturn ONLY a JSON object with postContent (the text including hashtags) and sentiment (positive/neutral/negative)\"\n    }]\n  }]\n}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "name": "Generate Post",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2816,
          -32
        ],
        "id": "7c494835-fa77-48c9-ae73-269be50bb6af",
        "retryOnFail": true,
        "maxTries": 5,
        "waitBetweenTries": 5000,
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Aggregate Compliant Topics\").first().json;\nconst hashtagData = $(\"Parse Hashtags\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const post = JSON.parse(cleaned);\n  return [{\n    json: {\n      postContent: post.postContent,\n      sentiment: post.sentiment || \"positive\",\n      safeImagePrompt: prevData.selectedTopic.safeImagePrompt,\n      anonymizedDescriptions: prevData.selectedTopic.anonymizedDescriptions || hashtagData.anonymizedDescriptions || {},\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.selectedTopic?.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      postContent: \"Football news update! Exciting developments in European football today.\",\n      sentiment: \"positive\",\n      safeImagePrompt: prevData.selectedTopic?.safeImagePrompt || \"Exciting football stadium scene with cheering fans\",\n      anonymizedDescriptions: prevData.selectedTopic?.anonymizedDescriptions || {},\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.selectedTopic?.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Post",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2000,
          112
        ],
        "id": "5ffc1c44-ad8f-4df3-bb2c-2ac5ec931d9f"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $input.first().json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "fb8ce752-bb66-4d73-abb2-24fad043a177",
        "name": "Generate Image",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2256,
          112
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Post\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const imageData = JSON.parse(cleaned);\n  return [{\n    json: {\n      imagePrompt: imageData.imagePrompt,\n      style: imageData.style || \"photorealistic\",\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      imagePrompt: \"Exciting football celebration scene in a modern stadium\",\n      style: \"photorealistic\",\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Image Prompt",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2512,
          112
        ],
        "id": "654ab797-28bc-4e88-a66c-74887fbedae5"
      },
      {
        "parameters": {
          "jsCode": "const brandingResult = $input.first().json;\nconst prevData = $(\"Parse Imagen Response\").first().json;\nconst aggregateData = $(\"Aggregate Compliant Topics\").first().json;\n\nconst postContent = prevData.postContent || \"Football news update!\";\nconst imagePrompt = prevData.imagePrompt || \"European football celebration\";\nconst sourceLink = prevData.sourceLink || \"\";\n\n// Get the selected topic from aggregation step (includes sourceHeadline)\nconst selectedTopic = aggregateData.selectedTopic || {};\n\n// Use branded image if available, otherwise fallback to original\nlet imageDataUri = prevData.imageDataUri || null;\nif (brandingResult.success && brandingResult.brandedImageBase64) {\n  imageDataUri = \"data:image/png;base64,\" + brandingResult.brandedImageBase64;\n}\n\n// Create transparency/disclosure post\nlet transparencyPost = \"I've developed this AI-driven system to efficiently curate European football news, serving as a professional 'proof of work' for AI integration. Grounded in transparency and the human-in-the-loop principle, this project demonstrates how AI can enhance specialized content. Follow for updates, or visit my bio to learn how to build similar systems.\\n\\nBilko Bibitkov Human-Centric AI Curation\";\n\nif (sourceLink) {\n  transparencyPost += \"\\n\\nSource: \" + sourceLink;\n}\n\nconst output = {\n  success: true,\n  selectedTopic: {\n    headline: selectedTopic.headline || \"\",\n    sourceHeadline: selectedTopic.sourceHeadline || selectedTopic.headline || \"\",\n    sourceHeadlineHash: selectedTopic.sourceHeadlineHash || \"\",\n    teams: selectedTopic.teams || [],\n    event: selectedTopic.event || \"\",\n    dataRichness: selectedTopic.dataRichness || 0,\n    brandValue: selectedTopic.brandValue || 0\n  },\n  data: {\n    postContent: postContent,\n    imagePrompt: imagePrompt,\n    imageUrl: imageDataUri,\n    transparencyPost: transparencyPost,\n    sourceLink: sourceLink,\n    contentFiltered: !imageDataUri,\n    brandingApplied: brandingResult.success === true\n  },\n  metadata: {\n    workflowId: \"european-football-daily\",\n    executedAt: new Date().toISOString(),\n    aiGenerated: true\n  }\n};\nreturn [{ json: output }];"
        },
        "name": "Build Final Output",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3600,
          112
        ],
        "id": "71b64e2c-1852-4ef6-a21d-732907892df3"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"final-output\",\n  \"stepIndex\": 3,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {{ JSON.stringify($input.first().json) }},\n  \"executionId\": \"{{ $execution.id }}\"\n}",
          "options": {}
        },
        "name": "Callback Final",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3008,
          112
        ],
        "id": "5a99a7c6-1f47-47eb-a13d-888ae0334bcf"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ $('Build Final Output').first().json }}",
          "options": {}
        },
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          3264,
          208
        ],
        "id": "4ea89a64-7267-4476-aac6-d67c10a7da98"
      },
      {
        "parameters": {
          "content": "PRODUCTION"
        },
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          416,
          496
        ],
        "id": "303bff0e-4feb-4c29-903e-cd2782ab38ba",
        "name": "Sticky Note"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"{{ $json.imagePrompt }}. Include bold stylized text overlay on the image saying: {{ $json.tagline }}\"\n    }]\n  }],\n  \"generation_config\": {\n    \"response_modalities\": [\"IMAGE\"],\n    \"image_config\": {\n      \"aspect_ratio\": \"1:1\"\n    }\n  }\n}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "74affa50-0102-49a6-8190-3e24f1ec0a2e",
        "name": "Call Imagen API",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3104,
          112
        ],
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Tagline\").first().json;\n\n// Get image from Nano Banana Pro response format\nconst parts = input?.candidates?.[0]?.content?.parts || [];\nconst imagePart = parts.find(p => p.inlineData?.mimeType?.startsWith(\"image/\"));\n\nif (imagePart && imagePart.inlineData?.data) {\n  const mimeType = imagePart.inlineData.mimeType;\n  const base64Data = imagePart.inlineData.data;\n  const imageDataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n\n  return [{\n    json: {\n      imageDataUri: imageDataUri,\n      imagePrompt: prevData.imagePrompt,\n      tagline: prevData.tagline,\n      postContent: prevData.postContent,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} else {\n  // Fallback when image generation fails\n  return [{\n    json: {\n      imageDataUri: null,\n      imagePrompt: prevData.imagePrompt,\n      tagline: prevData.tagline,\n      postContent: prevData.postContent,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      imagenError: \"No image data in response\"\n    }\n  }];\n}"
        },
        "id": "ec694419-9c45-4f5d-b2a9-56f136492315",
        "name": "Parse Imagen Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3360,
          112
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Analyze this football news headline and extract key information for social media.\\n\\nHEADLINE: {{ $json.title }}\\n\\nReturn ONLY a JSON object with:\\n- headline: the original headline\\n- teams: array of team names mentioned (prioritize big clubs: Real Madrid, Barcelona, Man City, Liverpool, Bayern, PSG, Juventus, etc.)\\n- event: brief description (match result, transfer, injury, etc.)\\n- hasScore: boolean - true if headline contains a match score like 3-0, 2-1\\n- hasNumbers: boolean - true if contains significant numbers (transfer fees, goals, points, positions)\\n- dataRichness: score 1-10 (10=has scores/stats/numbers, 5=has team names, 1=vague/generic)\\n- brandValue: score 1-10 (10=mentions top clubs/leagues/tournaments, 1=unknown teams)\\n- imageability: score 1-10 how easy to create a generic image\\n- imageSuggestion: a generic image concept avoiding real people names\\n\\nPrioritize headlines with: actual scores, transfer fees, league standings, big club names.\\nExample: { \\\"headline\\\": \\\"Barcelona 3-0 Real Madrid\\\", \\\"teams\\\": [\\\"Barcelona\\\", \\\"Real Madrid\\\"], \\\"event\\\": \\\"El Clasico victory\\\", \\\"hasScore\\\": true, \\\"hasNumbers\\\": true, \\\"dataRichness\\\": 10, \\\"brandValue\\\": 10, \\\"imageability\\\": 9, \\\"imageSuggestion\\\": \\\"celebrating football team in red and blue\\\" }\"\n    }]\n  }]\n}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 1,
                "batchInterval": 2000
              }
            }
          },
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "3bcffc23-1424-49a1-afd7-7f0514ed2ef7",
        "name": "Topic Analyst",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1312,
          -32
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst geminiApiKey = $(\"Webhook\").first().json.body.geminiApiKey;\nconst callbackUrl = $(\"Webhook\").first().json.body.callbackUrl;\n\n// Get the source article data from Extract Articles using item index\nconst articleItems = $(\"Extract Articles\").all();\nconst currentIndex = $runIndex;\nconst articleData = articleItems[currentIndex]?.json || {};\nconst sourceLink = articleData.link || \"\";\nconst sourceHeadline = articleData.sourceHeadline || articleData.title || \"\";\nconst sourceHeadlineHash = articleData.titleHash || \"\";\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const analysis = JSON.parse(cleaned);\n  return [{\n    json: {\n      ...analysis,\n      sourceLink: sourceLink,\n      sourceHeadline: sourceHeadline,\n      sourceHeadlineHash: sourceHeadlineHash,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      headline: \"Football news update\",\n      people: [],\n      teams: [],\n      event: \"general news\",\n      imageability: 5,\n      imageSuggestion: \"generic football stadium scene\",\n      sourceLink: sourceLink,\n      sourceHeadline: sourceHeadline,\n      sourceHeadlineHash: sourceHeadlineHash,\n      parseError: e.message,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}"
        },
        "id": "4a292d0b-d120-4074-87fc-6667de4e4de6",
        "name": "Parse Topic Analysis",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1616,
          -32
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 1,
                "batchInterval": 2000
              }
            }
          },
          "contentType": "json",
          "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "9c51724e-f9eb-4bea-a72c-3dbf6c163d0a",
        "name": "Compliance Checker",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1920,
          -32
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Topic Analysis\").first().json;\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const compliance = JSON.parse(cleaned);\n  return [{\n    json: {\n      headline: prevData.headline,\n      people: prevData.people,\n      teams: prevData.teams,\n      event: prevData.event,\n      imageability: prevData.imageability,\n      imageSuggestion: prevData.imageSuggestion,\n      sourceLink: prevData.sourceLink,\n      sourceHeadline: prevData.sourceHeadline,\n      sourceHeadlineHash: prevData.sourceHeadlineHash,\n      compliant: compliance.compliant !== false,\n      complianceReason: compliance.reason,\n      anonymizedDescriptions: compliance.anonymizedDescriptions || {},\n      safeImagePrompt: compliance.safeImagePrompt,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ...prevData,\n      compliant: true,\n      complianceReason: \"Parse error, using fallback: \" + e.message,\n      anonymizedDescriptions: {},\n      safeImagePrompt: \"Generic football stadium celebration scene with fans cheering\"\n    }\n  }];\n}"
        },
        "id": "e2dd7a80-e193-4290-a91b-542eb7f02b52",
        "name": "Parse Compliance Check",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2208,
          -32
        ]
      },
      {
        "parameters": {
          "jsCode": "// Collect all items (each article's compliance check result)\nconst items = $input.all();\nconst geminiApiKey = items[0]?.json?.geminiApiKey;\nconst callbackUrl = items[0]?.json?.callbackUrl;\n\n// Filter to only compliant topics and sort by data-richness + brand value\nconst compliantTopics = items\n  .map(item => item.json)\n  .filter(topic => topic.compliant === true)\n  .sort((a, b) => {\n    // Combined score prioritizing data-rich, high-brand topics\n    const scoreA = (a.dataRichness || 0) * 2 + (a.brandValue || 0) * 1.5 + (a.imageability || 0);\n    const scoreB = (b.dataRichness || 0) * 2 + (b.brandValue || 0) * 1.5 + (b.imageability || 0);\n    return scoreB - scoreA;\n  });\n\n// If no compliant topics, create a safe fallback\nif (compliantTopics.length === 0) {\n  return [{\n    json: {\n      selectedTopic: {\n        headline: 'European Football Weekly Update',\n        teams: [],\n        event: 'weekly roundup',\n        safeImagePrompt: 'Exciting football match scene in a packed stadium with cheering fans',\n        anonymizedDescriptions: {},\n        fallback: true\n      },\n      allTopics: items.map(i => i.json),\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}\n\n// Select the best topic (highest combined score)\nreturn [{\n  json: {\n    selectedTopic: compliantTopics[0],\n    alternativeTopics: compliantTopics.slice(1, 3),\n    allTopics: items.map(i => i.json),\n    geminiApiKey,\n    callbackUrl\n  }\n}];"
        },
        "id": "2426cf99-5a5b-4963-9ffc-81c4ec3cee01",
        "name": "Aggregate Compliant Topics",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2512,
          -32
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Find the 3 most relevant, high-reach hashtags for this European football topic.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\n\\nRules:\\n- Return EXACTLY 3 hashtags\\n- Must be real, widely-used hashtags on social media\\n- Must be directly relevant to this specific topic/teams/event\\n- Include the # symbol\\n- Prefer hashtags with high engagement (millions of posts)\\n\\nReturn ONLY a JSON object: {\\\"hashtags\\\": [\\\"#tag1\\\", \\\"#tag2\\\", \\\"#tag3\\\"]}\"\n    }]\n  }]\n}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "hashtag-researcher-1769380010487",
        "name": "Hashtag Researcher",
        "type": "n8n-nodes-base.httpRequest",
        "position": [
          2816,
          -32
        ],
        "typeVersion": 4.2,
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Get Gemini response from HTTP Request\nconst geminiResponse = $input.first().json;\n\n// Get original data from Aggregate Compliant Topics (2 nodes back)\nconst originalData = $(\"Aggregate Compliant Topics\").first().json;\nconst geminiApiKey = originalData.geminiApiKey;\nconst callbackUrl = originalData.callbackUrl;\nconst selectedTopic = originalData.selectedTopic;\n\n// Parse hashtags from Gemini response\nlet hashtags = [\"#football\", \"#soccer\", \"#UEFA\"]; // fallback\ntry {\n  const candidates = geminiResponse.candidates || [];\n  if (candidates.length > 0) {\n    let text = candidates[0].content?.parts?.[0]?.text || \"\";\n    text = text.replace(/```json\\n?/g, \"\").replace(/```/g, \"\").trim();\n    const parsed = JSON.parse(text);\n    if (parsed.hashtags && Array.isArray(parsed.hashtags)) {\n      hashtags = parsed.hashtags.slice(0, 3);\n    }\n  }\n} catch (e) {\n  // Keep fallback\n}\n\nreturn [{\n  json: {\n    selectedTopic: selectedTopic,\n    sourceLink: selectedTopic.sourceLink || \"\",\n    anonymizedDescriptions: selectedTopic.anonymizedDescriptions || {},\n    hashtags: hashtags,\n    hashtagString: hashtags.join(\" \"),\n    geminiApiKey: geminiApiKey,\n    callbackUrl: callbackUrl\n  }\n}];"
        },
        "id": "parse-hashtags-1769380010487",
        "name": "Parse Hashtags",
        "type": "n8n-nodes-base.code",
        "position": [
          3008,
          -32
        ],
        "typeVersion": 2
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "BilkoBibitkovApp/1.0"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create an informative headline for a European football image.\\n\\nTOPIC: {{ $json.selectedTopic?.headline || \\\"Football news\\\" }}\\nTEAMS: {{ ($json.selectedTopic?.teams || []).join(' vs ') }}\\nEVENT: {{ $json.selectedTopic?.event || \\\"update\\\" }}\\nHAS SCORE: {{ $json.selectedTopic?.hasScore || false }}\\nHAS NUMBERS: {{ $json.selectedTopic?.hasNumbers || false }}\\n\\nRules:\\n- 3-6 words maximum\\n- If HAS SCORE is true, INCLUDE the actual score from the headline (e.g., \\\"Barcelona 3-0 Madrid\\\")\\n- If HAS NUMBERS is true, include the key number (transfer fee, points, goals)\\n- Prioritize team names and factual information\\n- NO generic phrases like \\\"Game On\\\", \\\"Breaking News\\\", \\\"Big Win\\\", \\\"What A Match\\\"\\n- Should inform the viewer of WHAT happened, not just generate excitement\\n\\nGood examples:\\n- \\\"Barcelona 3-0 Real Madrid\\\"\\n- \\\"Man City Clinches Title\\\"\\n- \\\"Â£80M Transfer Complete\\\"\\n- \\\"Liverpool Top After Win\\\"\\n\\nBad examples (DO NOT USE):\\n- \\\"Game On!\\\"\\n- \\\"What A Match!\\\"\\n- \\\"Football Fever\\\"\\n- \\\"Big News Today\\\"\\n\\nReturn ONLY a JSON object: {\\\"tagline\\\": \\\"your informative headline here\\\"}\"\n    }]\n  }]\n}",
          "options": {
            "response": {
              "response": {}
            }
          },
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "name": "Generate Tagline",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2608,
          112
        ],
        "id": "tagline-gen-1769390960853",
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Image Prompt\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const taglineData = JSON.parse(cleaned);\n  return [{\n    json: {\n      tagline: taglineData.tagline || \"Game On!\",\n      imagePrompt: prevData.imagePrompt,\n      style: prevData.style,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      tagline: \"Game On!\",\n      imagePrompt: prevData.imagePrompt,\n      style: prevData.style,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Tagline",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2864,
          112
        ],
        "id": "parse-tagline-1769390960853"
      },
      {
        "id": "brand-image-node-1769619318863",
        "name": "Brand Image",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3580,
          112
        ],
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/images/brand",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ imageBase64: $json.imageDataUri ? $json.imageDataUri.replace(/^data:image\\/[^;]+;base64,/, \"\") : null }) }}",
          "options": {}
        }
      },
      {
        "id": "parse-brand-node-1769619318863",
        "name": "Parse Brand Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3800,
          112
        ],
        "parameters": {
          "jsCode": "const brandingResponse = $input.first().json;\nconst prevData = $(\"Parse Imagen Response\").first().json;\n\n// Pass through branding response with original data\nreturn [{\n  json: {\n    // Branding response fields\n    success: brandingResponse.success === true,\n    brandedImageBase64: brandingResponse.brandedImageBase64 || null,\n    \n    // Original data from Parse Imagen Response\n    imageDataUri: prevData.imageDataUri,\n    imagePrompt: prevData.imagePrompt,\n    tagline: prevData.tagline,\n    postContent: prevData.postContent,\n    sourceLink: prevData.sourceLink || \"\",\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}];"
        }
      },
      {
        "id": "cc_body_builder",
        "name": "Build Compliance Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1620,
          -32
        ],
        "parameters": {
          "jsCode": "// Build the Gemini API request body for compliance checking\nconst headline = $input.first().json.headline;\nconst people = $input.first().json.people || [];\nconst imageSuggestion = $input.first().json.imageSuggestion;\nconst geminiApiKey = $input.first().json.geminiApiKey;\nconst runIndex = $input.first().json.runIndex;\nconst link = $input.first().json.link;\n\nconst prompt = `You are an AI image compliance expert. Analyze this football topic and create anonymous visual descriptions.\n\nTOPIC: ${headline}\nPEOPLE: ${JSON.stringify(people)}\nIMAGE IDEA: ${imageSuggestion}\n\nFor each person listed, generate an anonymous physical description (height, build, hair, attire) without using their name.\n\nReturn ONLY valid JSON with these fields:\n- compliant: true\n- reason: why its safe for image generation  \n- anonymizedDescriptions: object mapping each person name to their anonymous description\n- safeImagePrompt: the image prompt rewritten with anonymous descriptions`;\n\nreturn {\n  json: {\n    headline,\n    people,\n    imageSuggestion,\n    geminiApiKey,\n    runIndex,\n    link,\n    requestBody: {\n      contents: [{\n        parts: [{ text: prompt }]\n      }]\n    }\n  }\n};\n"
        }
      },
      {
        "id": "gi_body_builder",
        "name": "Build Image Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2006,
          112
        ],
        "parameters": {
          "jsCode": "// Build the Gemini API request body for image prompt generation\nconst item = $input.first().json;\nconst safeImagePrompt = item.safeImagePrompt || '';\nconst anonymizedDescriptions = item.anonymizedDescriptions || {};\nconst geminiApiKey = item.geminiApiKey;\n\nconst prompt = `Create an image prompt for AI image generation based on this concept: ${safeImagePrompt}. \nInclude any people descriptions: ${JSON.stringify(anonymizedDescriptions)}.\nCreate a detailed, cinematic prompt. Focus on action and atmosphere. NO real person names.\nReturn ONLY valid JSON with: imagePrompt (your detailed prompt), style (photorealistic)`;\n\nreturn {\n  json: {\n    ...item,\n    requestBody: {\n      contents: [{\n        parts: [{ text: prompt }]\n      }]\n    }\n  }\n};\n"
        }
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Fetch RSS",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch RSS": {
        "main": [
          [
            {
              "node": "Parse XML",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse XML": {
        "main": [
          [
            {
              "node": "Extract Articles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Articles": {
        "main": [
          [
            {
              "node": "Topic Analyst",
              "type": "main",
              "index": 0
            },
            {
              "node": "Callback Articles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Post": {
        "main": [
          [
            {
              "node": "Parse Post",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Image": {
        "main": [
          [
            {
              "node": "Parse Image Prompt",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Final Output": {
        "main": [
          [
            {
              "node": "Callback Final",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Callback Final": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call Imagen API": {
        "main": [
          [
            {
              "node": "Parse Imagen Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Imagen Response": {
        "main": [
          [
            {
              "node": "Brand Image",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Topic Analyst": {
        "main": [
          [
            {
              "node": "Parse Topic Analysis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Topic Analysis": {
        "main": [
          [
            {
              "node": "Build Compliance Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Compliance Checker": {
        "main": [
          [
            {
              "node": "Parse Compliance Check",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Compliance Check": {
        "main": [
          [
            {
              "node": "Aggregate Compliant Topics",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Aggregate Compliant Topics": {
        "main": [
          [
            {
              "node": "Hashtag Researcher",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Post": {
        "main": [
          [
            {
              "node": "Build Image Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Image Prompt": {
        "main": [
          [
            {
              "node": "Generate Tagline",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Hashtag Researcher": {
        "main": [
          [
            {
              "node": "Parse Hashtags",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Hashtags": {
        "main": [
          [
            {
              "node": "Generate Post",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Tagline": {
        "main": [
          [
            {
              "node": "Parse Tagline",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Tagline": {
        "main": [
          [
            {
              "node": "Call Imagen API",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Brand Image": {
        "main": [
          [
            {
              "node": "Parse Brand Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Brand Response": {
        "main": [
          [
            {
              "node": "Build Final Output",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Compliance Request": {
        "main": [
          [
            {
              "node": "Compliance Checker",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Image Request": {
        "main": [
          [
            {
              "node": "Generate Image",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Bilko Bibitkov",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-01-31T22:24:51.846Z",
        "id": 161,
        "workflowId": "oV6WGX5uBeTZ9tRa",
        "versionId": "922d2045-d278-4ab5-9d7d-fa05025eb58e",
        "event": "activated",
        "userId": "80f5768f-36e3-4197-9886-2f8e29df41d7"
      }
    ]
  }
}
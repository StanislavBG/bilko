{
  "updatedAt": "2026-01-26T02:23:05.255Z",
  "createdAt": "2026-01-25T09:36:24.234Z",
  "id": "oV6WGX5uBeTZ9tRa",
  "name": "[PROD] European Football Daily",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 0 * * *"
            }
          ]
        }
      },
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "6a6b5bf5-ab53-4e6f-af46-184143ea6008"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "european-football-daily",
        "responseMode": "responseNode",
        "options": {}
      },
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        0,
        208
      ],
      "id": "0025e044-d2ba-4e9f-8e73-98ca642c1087",
      "webhookId": "191adfc0-b71a-41c2-8a26-25ca9ec0b6c1"
    },
    {
      "parameters": {},
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        256,
        112
      ],
      "id": "a7a00ee0-650d-4506-85d1-d83c0e66f6ae"
    },
    {
      "parameters": {
        "url": "https://news.google.com/rss/search?q=european+football+champions+league+OR+premier+league+OR+la+liga+OR+bundesliga+OR+serie+a&hl=en-US&gl=US&ceid=US:en",
        "options": {}
      },
      "name": "Fetch RSS",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        512,
        112
      ],
      "id": "a0c4d441-f13a-4003-8f49-1a710d29c12e"
    },
    {
      "parameters": {
        "options": {}
      },
      "name": "Parse XML",
      "type": "n8n-nodes-base.xml",
      "typeVersion": 1,
      "position": [
        752,
        112
      ],
      "id": "9466c9e8-2426-4e44-8a8e-ef37a1138c38"
    },
    {
      "parameters": {
        "jsCode": "const rss = $input.first().json;\nconst items = rss?.rss?.channel?.item || [];\nconst articles = items.slice(0, 10).map(item => ({\n  title: item.title || '',\n  link: item.link || '',\n  source: 'Google News',\n  pubDate: item.pubDate || ''\n}));\nreturn articles.map(a => ({ json: a }));"
      },
      "name": "Extract Articles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        112
      ],
      "id": "2a98ef6a-8bc2-4312-9ae1-9c72f99e4b84"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"extract-articles\",\n  \"stepIndex\": 1,\n  \"traceId\": \"{{ $('Webhook').first().json.traceId || $('Merge Triggers').first().json.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"articles\": {{ JSON.stringify($input.all().map(i => i.json)) }},\n    \"count\": {{ $input.all().length }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
        "options": {}
      },
      "name": "Callback Articles",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1104,
        256
      ],
      "id": "c6ed77f1-fb89-4efe-875f-2c7668fa7140"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $json.geminiApiKey }}",
        "sendQuery": false,
        "queryParameters": {
          "parameters": []
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $input.first().json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are a passionate European football social media manager. Create an engaging Facebook post.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\nHASHTAGS TO USE: {{ $json.hashtagString }}\\n\\nCreate an exciting Facebook post (2-3 paragraphs max) that:\\n1. Opens with energy and excitement\\n2. Highlights the key story\\n3. Invites engagement (follow, comment)\\n4. MUST end with these EXACT hashtags: {{ $json.hashtagString }}\\n\\nIMPORTANT: Do NOT mention specific player or coach names. Focus on TEAM and EVENT.\\n\\nReturn ONLY a JSON object with postContent (the text including hashtags) and sentiment (positive/neutral/negative)\"\n    }]\n  }]\n}",
        "options": {}
      },
      "name": "Generate Post",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2808,
        -38
      ],
      "id": "7c494835-fa77-48c9-ae73-269be50bb6af",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $('Aggregate Compliant Topics').first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, '').replace(/\n?```s*$/, '');\n\ntry {\n  const post = JSON.parse(cleaned);\n  return [{\n    json: {\n      postContent: post.postContent,\n      sentiment: post.sentiment || 'positive',\n      // Pass along the pre-validated safe image prompt from compliance check\n      safeImagePrompt: prevData.selectedTopic.safeImagePrompt,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.selectedTopic?.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      postContent: 'Football news update! Exciting developments in European football today.',\n      sentiment: 'positive',\n      safeImagePrompt: prevData.selectedTopic?.safeImagePrompt || 'Exciting football stadium scene with cheering fans',\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.selectedTopic?.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Post",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        112
      ],
      "id": "5ffc1c44-ad8f-4df3-bb2c-2ac5ec931d9f"
    },
    {
      "id": "fb8ce752-bb66-4d73-abb2-24fad043a177",
      "name": "Generate Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2256,
        112
      ],
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $json.geminiApiKey }}",
        "sendQuery": false,
        "queryParameters": {
          "parameters": []
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $input.first().json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create an image prompt for AI image generation.\\n\\nBASE CONCEPT: {{ $json.safeImagePrompt }}\\nPOST TOPIC: {{ $json.postContent ? $json.postContent.substring(0, 100) : 'Football celebration' }}\\n\\nCreate a detailed, cinematic image prompt. NO real person names. Focus on action, celebration, atmosphere.\\n\\nReturn ONLY a JSON object with imagePrompt (the description) and style (photorealistic/dramatic)\"\n    }]\n  }]\n}",
        "options": {}
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $('Parse Post').first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, '').replace(/\n?```s*$/, '');\n\ntry {\n  const imageData = JSON.parse(cleaned);\n  return [{\n    json: {\n      imagePrompt: imageData.imagePrompt,\n      style: imageData.style || 'photorealistic',\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      imagePrompt: 'Exciting football celebration scene in a modern stadium',\n      style: 'photorealistic',\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Image Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2512,
        112
      ],
      "id": "654ab797-28bc-4e88-a66c-74887fbedae5"
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst postContent = input.postContent || 'Football news update!';\nconst imagePrompt = input.imagePrompt || 'European football celebration';\nconst imageDataUri = input.imageDataUri || null;\nconst sourceLink = input.sourceLink || '';\n\n// Create transparency/disclosure post - flowing sentences, no hashtags, includes source link\nlet transparencyPost = \"Why am I doing this? Let me be transparent. I love European football but don't have time to search for news, so I built a system where the news comes to me - if you're into football too, follow along and give me feedback so we can vibe together! Want to learn how to create content like this? I can help, check the link in bio. I'm learning to thrive in the AI age (it's already here, in case you haven't noticed), and this is my playground and my proof of work. Full transparency, trust, and compliance matter to me. I'm Bilko Bibitkov - human in the loop, always.\";\n\n// Add source attribution if we have a link\nif (sourceLink) {\n  transparencyPost += \"\n\nSource: \" + sourceLink;\n}\n\nconst output = {\n  success: true,\n  data: {\n    postContent: postContent,\n    imagePrompt: imagePrompt,\n    imageUrl: imageDataUri,\n    transparencyPost: transparencyPost,\n    sourceLink: sourceLink,\n    contentFiltered: !imageDataUri\n  },\n  metadata: {\n    workflowId: \"european-football-daily\",\n    executedAt: new Date().toISOString(),\n    aiGenerated: true\n  }\n};\nreturn [{ json: output }];"
      },
      "name": "Build Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        112
      ],
      "id": "71b64e2c-1852-4ef6-a21d-732907892df3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"final-output\",\n  \"stepIndex\": 3,\n  \"traceId\": \"{{ $('Webhook').first().json.traceId || $('Merge Triggers').first().json.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {{ JSON.stringify($input.first().json) }},\n  \"executionId\": \"{{ $execution.id }}\"\n}",
        "options": {}
      },
      "name": "Callback Final",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3008,
        112
      ],
      "id": "5a99a7c6-1f47-47eb-a13d-888ae0334bcf"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $('Build Final Output').first().json }}",
        "options": {}
      },
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        3264,
        208
      ],
      "id": "4ea89a64-7267-4476-aac6-d67c10a7da98"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        208,
        368
      ],
      "id": "303bff0e-4feb-4c29-903e-cd2782ab38ba",
      "name": "Sticky Note"
    },
    {
      "id": "74affa50-0102-49a6-8190-3e24f1ec0a2e",
      "name": "Call Imagen API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3100,
        112
      ],
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent?key={{ $(\"Parse Tagline\").first().json.geminiApiKey }}",
        "sendQuery": false,
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"{{ $json.imagePrompt }}. Include bold stylized text overlay on the image saying: {{ $json.tagline }}\"\n    }]\n  }],\n  \"generation_config\": {\n    \"response_modalities\": [\"IMAGE\"],\n    \"image_config\": {\n      \"aspect_ratio\": \"1:1\"\n    }\n  }\n}",
        "options": {}
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000
    },
    {
      "id": "ec694419-9c45-4f5d-b2a9-56f136492315",
      "name": "Parse Imagen Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3350,
        112
      ],
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $('Parse Tagline').first().json;\n\n// Get image from new Nano Banana Pro response format\nconst parts = input?.candidates?.[0]?.content?.parts || [];\nconst imagePart = parts.find(p => p.inlineData?.mimeType?.startsWith('image/'));\n\nif (imagePart && imagePart.inlineData?.data) {\n  const mimeType = imagePart.inlineData.mimeType;\n  const base64Data = imagePart.inlineData.data;\n  const imageDataUri = 'data:' + mimeType + ';base64,' + base64Data;\n  \n  return [{\n    json: {\n      imageDataUri: imageDataUri,\n      imagePrompt: prevData.imagePrompt,\n      tagline: prevData.tagline,\n      postContent: prevData.postContent,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} else {\n  // Fallback when image generation fails\n  return [{\n    json: {\n      imageDataUri: null,\n      imagePrompt: prevData.imagePrompt,\n      tagline: prevData.tagline,\n      postContent: prevData.postContent,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      imagenError: 'No image data in response'\n    }\n  }];\n}"
      }
    },
    {
      "id": "3bcffc23-1424-49a1-afd7-7f0514ed2ef7",
      "name": "Topic Analyst",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1308,
        -38
      ],
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $('Webhook').first().json.body.geminiApiKey }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Analyze this football news headline and extract key entities:\\n\\nHEADLINE: {{ $json.title }}\\n\\nReturn ONLY a JSON object with:\\n- headline: the original headline\\n- people: array of person names mentioned (players, coaches, etc)\\n- teams: array of team names mentioned\\n- event: brief description of the event (match, transfer, injury, etc)\\n- imageability: score 1-10 how easy to create a generic image (10=easy, 1=hard)\\n- imageSuggestion: a generic image concept that avoids real people names\\n\\nExample: { \\\"headline\\\": \\\"Barcelona wins 3-0\\\", \\\"people\\\": [], \\\"teams\\\": [\\\"Barcelona\\\"], \\\"event\\\": \\\"match victory\\\", \\\"imageability\\\": 9, \\\"imageSuggestion\\\": \\\"celebrating football team in red and blue\\\" }\"\n    }]\n  }]\n}",
        "options": {}
      }
    },
    {
      "id": "4a292d0b-d120-4074-87fc-6667de4e4de6",
      "name": "Parse Topic Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1608,
        -38
      ],
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst geminiApiKey = $('Webhook').first().json.body.geminiApiKey;\nconst callbackUrl = $('Webhook').first().json.body.callbackUrl;\n\n// In n8n batch mode, use $input.item to get the paired item context\n// But for HTTP Request nodes, we need to get it differently\n// The input to Topic Analyst came from Extract Articles, so we can reference it\nconst articleItems = $('Extract Articles').all();\nconst currentIndex = $runIndex;\nconst articleData = articleItems[currentIndex]?.json || {};\nconst sourceLink = articleData.link || '';\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, '').replace(/\n?```s*$/, '');\n\ntry {\n  const analysis = JSON.parse(cleaned);\n  return [{\n    json: {\n      ...analysis,\n      sourceLink: sourceLink,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n} catch (e) {\n  // If parsing fails, create a safe fallback\n  return [{\n    json: {\n      headline: 'Football news update',\n      people: [],\n      teams: [],\n      event: 'general news',\n      imageability: 5,\n      imageSuggestion: 'generic football stadium scene',\n      sourceLink: sourceLink,\n      parseError: e.message,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}"
      }
    },
    {
      "id": "9c51724e-f9eb-4bea-a72c-3dbf6c163d0a",
      "name": "Compliance Checker",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1908,
        -38
      ],
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $json.geminiApiKey }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are an AI image compliance checker. Review this football topic for AI image generation safety.\\n\\nTOPIC: {{ $json.headline }}\\nPEOPLE MENTIONED: {{ JSON.stringify($json.people || []) }}\\nSUGGESTED IMAGE: {{ $json.imageSuggestion }}\\n\\nRULES:\\n1. Real person names (players, coaches) = SKIP (AI image APIs reject these)\\n2. Generic team celebrations = OK\\n3. Stadium/crowd scenes = OK\\n4. Trophy/celebration scenes without named individuals = OK\\n\\nReturn ONLY a JSON object:\\n- compliant: true/false (false if real people are central to the story)\\n- reason: why compliant or not\\n- safeImagePrompt: rewritten prompt that will definitely work (no names, generic descriptions)\\n- originalData: pass through the topic data\\n\\nIMPORTANT: If people array has names, this is likely NOT compliant unless the story is about the team, not the individual.\"\n    }]\n  }]\n}",
        "options": {}
      }
    },
    {
      "id": "e2dd7a80-e193-4290-a91b-542eb7f02b52",
      "name": "Parse Compliance Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2208,
        -38
      ],
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $('Parse Topic Analysis').first().json;\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, '').replace(/\n?```s*$/, '');\n\ntry {\n  const compliance = JSON.parse(cleaned);\n  return [{\n    json: {\n      headline: prevData.headline,\n      people: prevData.people,\n      teams: prevData.teams,\n      event: prevData.event,\n      imageability: prevData.imageability,\n      imageSuggestion: prevData.imageSuggestion,\n      sourceLink: prevData.sourceLink,\n      compliant: compliance.compliant,\n      complianceReason: compliance.reason,\n      safeImagePrompt: compliance.safeImagePrompt,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  // If parsing fails, mark as non-compliant to be safe\n  return [{\n    json: {\n      ...prevData,\n      compliant: false,\n      complianceReason: 'Parse error: ' + e.message,\n      safeImagePrompt: 'Generic football stadium celebration scene with fans cheering'\n    }\n  }];\n}"
      }
    },
    {
      "id": "2426cf99-5a5b-4963-9ffc-81c4ec3cee01",
      "name": "Aggregate Compliant Topics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2508,
        -38
      ],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Collect all items (each article's compliance check result)\nconst items = $input.all();\nconst geminiApiKey = items[0]?.json?.geminiApiKey;\nconst callbackUrl = items[0]?.json?.callbackUrl;\n\n// Filter to only compliant topics and sort by imageability\nconst compliantTopics = items\n  .map(item => item.json)\n  .filter(topic => topic.compliant === true)\n  .sort((a, b) => (b.imageability || 0) - (a.imageability || 0));\n\n// If no compliant topics, create a safe fallback\nif (compliantTopics.length === 0) {\n  return [{\n    json: {\n      selectedTopic: {\n        headline: 'European Football Weekly Update',\n        teams: [],\n        event: 'weekly roundup',\n        safeImagePrompt: 'Exciting football match scene in a packed stadium with cheering fans',\n        sourceLink: '',\n        fallback: true\n      },\n      allTopics: items.map(i => i.json),\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}\n\n// Select the best topic (highest imageability score)\nreturn [{\n  json: {\n    selectedTopic: compliantTopics[0],\n    alternativeTopics: compliantTopics.slice(1, 3),\n    allTopics: items.map(i => i.json),\n    geminiApiKey,\n    callbackUrl\n  }\n}];"
      }
    },
    {
      "id": "hashtag-researcher-1769380010487",
      "name": "Hashtag Researcher",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        2808,
        -38
      ],
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Find the 3 most relevant, high-reach hashtags for this European football topic.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\n\\nRules:\\n- Return EXACTLY 3 hashtags\\n- Must be real, widely-used hashtags on social media\\n- Must be directly relevant to this specific topic/teams/event\\n- Include the # symbol\\n- Prefer hashtags with high engagement (millions of posts)\\n\\nReturn ONLY a JSON object: {\\\"hashtags\\\": [\\\"#tag1\\\", \\\"#tag2\\\", \\\"#tag3\\\"]}\"\n    }]\n  }]\n}"
      },
      "typeVersion": 4.2
    },
    {
      "id": "parse-hashtags-1769380010487",
      "name": "Parse Hashtags",
      "type": "n8n-nodes-base.code",
      "position": [
        3008,
        -38
      ],
      "parameters": {
        "jsCode": "// Get Gemini response from HTTP Request\nconst geminiResponse = $input.first().json;\n\n// Get original data from Aggregate Compliant Topics (2 nodes back)\nconst originalData = $('Aggregate Compliant Topics').first().json;\nconst geminiApiKey = originalData.geminiApiKey;\nconst callbackUrl = originalData.callbackUrl;\nconst selectedTopic = originalData.selectedTopic;\n\n// Parse hashtags from Gemini response\nlet hashtags = ['#football', '#soccer', '#UEFA']; // fallback\ntry {\n  const candidates = geminiResponse.candidates || [];\n  if (candidates.length > 0) {\n    let text = candidates[0].content?.parts?.[0]?.text || '';\n    text = text.replace(/```json\n?/g, '').replace(/```/g, '').trim();\n    const parsed = JSON.parse(text);\n    if (parsed.hashtags && Array.isArray(parsed.hashtags)) {\n      hashtags = parsed.hashtags.slice(0, 3);\n    }\n  }\n} catch (e) {\n  // Keep fallback\n}\n\nreturn [{\n  json: {\n    selectedTopic: selectedTopic,\n    sourceLink: selectedTopic.sourceLink || '',\n    hashtags: hashtags,\n    hashtagString: hashtags.join(' '),\n    geminiApiKey: geminiApiKey,\n    callbackUrl: callbackUrl\n  }\n}];"
      },
      "typeVersion": 2
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $json.geminiApiKey }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "BilkoBibitkovApp/1.0"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create a short, punchy tagline for a European football social media image.\n\nTOPIC: {{ $json.selectedTopic }}\nPOST PREVIEW: {{ $json.postContent ? $json.postContent.substring(0, 100) : 'Football update' }}\n\nRules:\n- Maximum 4-5 words\n- Catchy and memorable\n- No hashtags\n- Use action words or emotions\n- Should work overlaid on a football image\n\nReturn ONLY a JSON object: {\"tagline\": \"your tagline here\"}\"\n    }]\n  }]\n}",
        "options": {
          "response": {
            "response": {
              "fullResponse": false
            }
          }
        }
      },
      "name": "Generate Tagline",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2600,
        112
      ],
      "id": "tagline-gen-1769390960853"
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Image Prompt\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, \"\").replace(/\n?```s*$/, \"\");\n\ntry {\n  const taglineData = JSON.parse(cleaned);\n  return [{\n    json: {\n      tagline: taglineData.tagline || \"Game On!\",\n      imagePrompt: prevData.imagePrompt,\n      style: prevData.style,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      tagline: \"Game On!\",\n      imagePrompt: prevData.imagePrompt,\n      style: prevData.style,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Tagline",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2850,
        112
      ],
      "id": "parse-tagline-1769390960853"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Fetch RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch RSS": {
      "main": [
        [
          {
            "node": "Parse XML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse XML": {
      "main": [
        [
          {
            "node": "Extract Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Articles": {
      "main": [
        [
          {
            "node": "Topic Analyst",
            "type": "main",
            "index": 0
          },
          {
            "node": "Callback Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Post": {
      "main": [
        [
          {
            "node": "Parse Post",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Image": {
      "main": [
        [
          {
            "node": "Parse Image Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Final Output": {
      "main": [
        [
          {
            "node": "Callback Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Callback Final": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Imagen API": {
      "main": [
        [
          {
            "node": "Parse Imagen Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Imagen Response": {
      "main": [
        [
          {
            "node": "Build Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Topic Analyst": {
      "main": [
        [
          {
            "node": "Parse Topic Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Topic Analysis": {
      "main": [
        [
          {
            "node": "Compliance Checker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compliance Checker": {
      "main": [
        [
          {
            "node": "Parse Compliance Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Compliance Check": {
      "main": [
        [
          {
            "node": "Aggregate Compliant Topics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Compliant Topics": {
      "main": [
        [
          {
            "node": "Hashtag Researcher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Post": {
      "main": [
        [
          {
            "node": "Generate Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Image Prompt": {
      "main": [
        [
          {
            "node": "Generate Tagline",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hashtag Researcher": {
      "main": [
        [
          {
            "node": "Parse Hashtags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Hashtags": {
      "main": [
        [
          {
            "node": "Generate Post",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Tagline": {
      "main": [
        [
          {
            "node": "Parse Tagline",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Tagline": {
      "main": [
        [
          {
            "node": "Call Imagen API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "node:Schedule Trigger": {
      "recurrenceRules": []
    }
  },
  "meta": null,
  "pinData": {},
  "versionId": "6ea4bcc2-ac7b-47f6-8538-2bf7e2dee1c9",
  "activeVersionId": "6ea4bcc2-ac7b-47f6-8538-2bf7e2dee1c9",
  "versionCounter": 224,
  "triggerCount": 2,
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-01-26T02:23:05.256Z",
    "createdAt": "2026-01-26T02:23:05.256Z",
    "versionId": "6ea4bcc2-ac7b-47f6-8538-2bf7e2dee1c9",
    "workflowId": "oV6WGX5uBeTZ9tRa",
    "nodes": [
      {
        "parameters": {
          "rule": {
            "interval": [
              {
                "field": "cronExpression",
                "expression": "0 0 * * *"
              }
            ]
          }
        },
        "name": "Schedule Trigger",
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1,
        "position": [
          0,
          0
        ],
        "id": "6a6b5bf5-ab53-4e6f-af46-184143ea6008"
      },
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "european-football-daily",
          "responseMode": "responseNode",
          "options": {}
        },
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 1,
        "position": [
          0,
          208
        ],
        "id": "0025e044-d2ba-4e9f-8e73-98ca642c1087",
        "webhookId": "191adfc0-b71a-41c2-8a26-25ca9ec0b6c1"
      },
      {
        "parameters": {},
        "name": "Merge Triggers",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 2,
        "position": [
          256,
          112
        ],
        "id": "a7a00ee0-650d-4506-85d1-d83c0e66f6ae"
      },
      {
        "parameters": {
          "url": "https://news.google.com/rss/search?q=european+football+champions+league+OR+premier+league+OR+la+liga+OR+bundesliga+OR+serie+a&hl=en-US&gl=US&ceid=US:en",
          "options": {}
        },
        "name": "Fetch RSS",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          512,
          112
        ],
        "id": "a0c4d441-f13a-4003-8f49-1a710d29c12e"
      },
      {
        "parameters": {
          "options": {}
        },
        "name": "Parse XML",
        "type": "n8n-nodes-base.xml",
        "typeVersion": 1,
        "position": [
          752,
          112
        ],
        "id": "9466c9e8-2426-4e44-8a8e-ef37a1138c38"
      },
      {
        "parameters": {
          "jsCode": "const rss = $input.first().json;\nconst items = rss?.rss?.channel?.item || [];\nconst articles = items.slice(0, 10).map(item => ({\n  title: item.title || '',\n  link: item.link || '',\n  source: 'Google News',\n  pubDate: item.pubDate || ''\n}));\nreturn articles.map(a => ({ json: a }));"
        },
        "name": "Extract Articles",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1008,
          112
        ],
        "id": "2a98ef6a-8bc2-4312-9ae1-9c72f99e4b84"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"extract-articles\",\n  \"stepIndex\": 1,\n  \"traceId\": \"{{ $('Webhook').first().json.traceId || $('Merge Triggers').first().json.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"articles\": {{ JSON.stringify($input.all().map(i => i.json)) }},\n    \"count\": {{ $input.all().length }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
          "options": {}
        },
        "name": "Callback Articles",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1104,
          256
        ],
        "id": "c6ed77f1-fb89-4efe-875f-2c7668fa7140"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $json.geminiApiKey }}",
          "sendQuery": false,
          "queryParameters": {
            "parameters": []
          },
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $input.first().json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are a passionate European football social media manager. Create an engaging Facebook post.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\nHASHTAGS TO USE: {{ $json.hashtagString }}\\n\\nCreate an exciting Facebook post (2-3 paragraphs max) that:\\n1. Opens with energy and excitement\\n2. Highlights the key story\\n3. Invites engagement (follow, comment)\\n4. MUST end with these EXACT hashtags: {{ $json.hashtagString }}\\n\\nIMPORTANT: Do NOT mention specific player or coach names. Focus on TEAM and EVENT.\\n\\nReturn ONLY a JSON object with postContent (the text including hashtags) and sentiment (positive/neutral/negative)\"\n    }]\n  }]\n}",
          "options": {}
        },
        "name": "Generate Post",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2808,
          -38
        ],
        "id": "7c494835-fa77-48c9-ae73-269be50bb6af",
        "retryOnFail": true,
        "maxTries": 5,
        "waitBetweenTries": 5000
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $('Aggregate Compliant Topics').first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, '').replace(/\n?```s*$/, '');\n\ntry {\n  const post = JSON.parse(cleaned);\n  return [{\n    json: {\n      postContent: post.postContent,\n      sentiment: post.sentiment || 'positive',\n      // Pass along the pre-validated safe image prompt from compliance check\n      safeImagePrompt: prevData.selectedTopic.safeImagePrompt,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.selectedTopic?.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      postContent: 'Football news update! Exciting developments in European football today.',\n      sentiment: 'positive',\n      safeImagePrompt: prevData.selectedTopic?.safeImagePrompt || 'Exciting football stadium scene with cheering fans',\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.selectedTopic?.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Post",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2000,
          112
        ],
        "id": "5ffc1c44-ad8f-4df3-bb2c-2ac5ec931d9f"
      },
      {
        "id": "fb8ce752-bb66-4d73-abb2-24fad043a177",
        "name": "Generate Image",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2256,
          112
        ],
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $json.geminiApiKey }}",
          "sendQuery": false,
          "queryParameters": {
            "parameters": []
          },
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $input.first().json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create an image prompt for AI image generation.\\n\\nBASE CONCEPT: {{ $json.safeImagePrompt }}\\nPOST TOPIC: {{ $json.postContent ? $json.postContent.substring(0, 100) : 'Football celebration' }}\\n\\nCreate a detailed, cinematic image prompt. NO real person names. Focus on action, celebration, atmosphere.\\n\\nReturn ONLY a JSON object with imagePrompt (the description) and style (photorealistic/dramatic)\"\n    }]\n  }]\n}",
          "options": {}
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $('Parse Post').first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, '').replace(/\n?```s*$/, '');\n\ntry {\n  const imageData = JSON.parse(cleaned);\n  return [{\n    json: {\n      imagePrompt: imageData.imagePrompt,\n      style: imageData.style || 'photorealistic',\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      imagePrompt: 'Exciting football celebration scene in a modern stadium',\n      style: 'photorealistic',\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Image Prompt",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2512,
          112
        ],
        "id": "654ab797-28bc-4e88-a66c-74887fbedae5"
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst postContent = input.postContent || 'Football news update!';\nconst imagePrompt = input.imagePrompt || 'European football celebration';\nconst imageDataUri = input.imageDataUri || null;\nconst sourceLink = input.sourceLink || '';\n\n// Create transparency/disclosure post - flowing sentences, no hashtags, includes source link\nlet transparencyPost = \"Why am I doing this? Let me be transparent. I love European football but don't have time to search for news, so I built a system where the news comes to me - if you're into football too, follow along and give me feedback so we can vibe together! Want to learn how to create content like this? I can help, check the link in bio. I'm learning to thrive in the AI age (it's already here, in case you haven't noticed), and this is my playground and my proof of work. Full transparency, trust, and compliance matter to me. I'm Bilko Bibitkov - human in the loop, always.\";\n\n// Add source attribution if we have a link\nif (sourceLink) {\n  transparencyPost += \"\n\nSource: \" + sourceLink;\n}\n\nconst output = {\n  success: true,\n  data: {\n    postContent: postContent,\n    imagePrompt: imagePrompt,\n    imageUrl: imageDataUri,\n    transparencyPost: transparencyPost,\n    sourceLink: sourceLink,\n    contentFiltered: !imageDataUri\n  },\n  metadata: {\n    workflowId: \"european-football-daily\",\n    executedAt: new Date().toISOString(),\n    aiGenerated: true\n  }\n};\nreturn [{ json: output }];"
        },
        "name": "Build Final Output",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3600,
          112
        ],
        "id": "71b64e2c-1852-4ef6-a21d-732907892df3"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"final-output\",\n  \"stepIndex\": 3,\n  \"traceId\": \"{{ $('Webhook').first().json.traceId || $('Merge Triggers').first().json.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {{ JSON.stringify($input.first().json) }},\n  \"executionId\": \"{{ $execution.id }}\"\n}",
          "options": {}
        },
        "name": "Callback Final",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3008,
          112
        ],
        "id": "5a99a7c6-1f47-47eb-a13d-888ae0334bcf"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ $('Build Final Output').first().json }}",
          "options": {}
        },
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          3264,
          208
        ],
        "id": "4ea89a64-7267-4476-aac6-d67c10a7da98"
      },
      {
        "parameters": {},
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          208,
          368
        ],
        "id": "303bff0e-4feb-4c29-903e-cd2782ab38ba",
        "name": "Sticky Note"
      },
      {
        "id": "74affa50-0102-49a6-8190-3e24f1ec0a2e",
        "name": "Call Imagen API",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3100,
          112
        ],
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent?key={{ $(\"Parse Tagline\").first().json.geminiApiKey }}",
          "sendQuery": false,
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"{{ $json.imagePrompt }}. Include bold stylized text overlay on the image saying: {{ $json.tagline }}\"\n    }]\n  }],\n  \"generation_config\": {\n    \"response_modalities\": [\"IMAGE\"],\n    \"image_config\": {\n      \"aspect_ratio\": \"1:1\"\n    }\n  }\n}",
          "options": {}
        },
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000
      },
      {
        "id": "ec694419-9c45-4f5d-b2a9-56f136492315",
        "name": "Parse Imagen Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3350,
          112
        ],
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $('Parse Tagline').first().json;\n\n// Get image from new Nano Banana Pro response format\nconst parts = input?.candidates?.[0]?.content?.parts || [];\nconst imagePart = parts.find(p => p.inlineData?.mimeType?.startsWith('image/'));\n\nif (imagePart && imagePart.inlineData?.data) {\n  const mimeType = imagePart.inlineData.mimeType;\n  const base64Data = imagePart.inlineData.data;\n  const imageDataUri = 'data:' + mimeType + ';base64,' + base64Data;\n  \n  return [{\n    json: {\n      imageDataUri: imageDataUri,\n      imagePrompt: prevData.imagePrompt,\n      tagline: prevData.tagline,\n      postContent: prevData.postContent,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} else {\n  // Fallback when image generation fails\n  return [{\n    json: {\n      imageDataUri: null,\n      imagePrompt: prevData.imagePrompt,\n      tagline: prevData.tagline,\n      postContent: prevData.postContent,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      imagenError: 'No image data in response'\n    }\n  }];\n}"
        }
      },
      {
        "id": "3bcffc23-1424-49a1-afd7-7f0514ed2ef7",
        "name": "Topic Analyst",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1308,
          -38
        ],
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $('Webhook').first().json.body.geminiApiKey }}",
          "authentication": "none",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "contentType": "json",
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Analyze this football news headline and extract key entities:\\n\\nHEADLINE: {{ $json.title }}\\n\\nReturn ONLY a JSON object with:\\n- headline: the original headline\\n- people: array of person names mentioned (players, coaches, etc)\\n- teams: array of team names mentioned\\n- event: brief description of the event (match, transfer, injury, etc)\\n- imageability: score 1-10 how easy to create a generic image (10=easy, 1=hard)\\n- imageSuggestion: a generic image concept that avoids real people names\\n\\nExample: { \\\"headline\\\": \\\"Barcelona wins 3-0\\\", \\\"people\\\": [], \\\"teams\\\": [\\\"Barcelona\\\"], \\\"event\\\": \\\"match victory\\\", \\\"imageability\\\": 9, \\\"imageSuggestion\\\": \\\"celebrating football team in red and blue\\\" }\"\n    }]\n  }]\n}",
          "options": {}
        }
      },
      {
        "id": "4a292d0b-d120-4074-87fc-6667de4e4de6",
        "name": "Parse Topic Analysis",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1608,
          -38
        ],
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst geminiApiKey = $('Webhook').first().json.body.geminiApiKey;\nconst callbackUrl = $('Webhook').first().json.body.callbackUrl;\n\n// In n8n batch mode, use $input.item to get the paired item context\n// But for HTTP Request nodes, we need to get it differently\n// The input to Topic Analyst came from Extract Articles, so we can reference it\nconst articleItems = $('Extract Articles').all();\nconst currentIndex = $runIndex;\nconst articleData = articleItems[currentIndex]?.json || {};\nconst sourceLink = articleData.link || '';\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, '').replace(/\n?```s*$/, '');\n\ntry {\n  const analysis = JSON.parse(cleaned);\n  return [{\n    json: {\n      ...analysis,\n      sourceLink: sourceLink,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n} catch (e) {\n  // If parsing fails, create a safe fallback\n  return [{\n    json: {\n      headline: 'Football news update',\n      people: [],\n      teams: [],\n      event: 'general news',\n      imageability: 5,\n      imageSuggestion: 'generic football stadium scene',\n      sourceLink: sourceLink,\n      parseError: e.message,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}"
        }
      },
      {
        "id": "9c51724e-f9eb-4bea-a72c-3dbf6c163d0a",
        "name": "Compliance Checker",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1908,
          -38
        ],
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $json.geminiApiKey }}",
          "authentication": "none",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "contentType": "json",
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are an AI image compliance checker. Review this football topic for AI image generation safety.\\n\\nTOPIC: {{ $json.headline }}\\nPEOPLE MENTIONED: {{ JSON.stringify($json.people || []) }}\\nSUGGESTED IMAGE: {{ $json.imageSuggestion }}\\n\\nRULES:\\n1. Real person names (players, coaches) = SKIP (AI image APIs reject these)\\n2. Generic team celebrations = OK\\n3. Stadium/crowd scenes = OK\\n4. Trophy/celebration scenes without named individuals = OK\\n\\nReturn ONLY a JSON object:\\n- compliant: true/false (false if real people are central to the story)\\n- reason: why compliant or not\\n- safeImagePrompt: rewritten prompt that will definitely work (no names, generic descriptions)\\n- originalData: pass through the topic data\\n\\nIMPORTANT: If people array has names, this is likely NOT compliant unless the story is about the team, not the individual.\"\n    }]\n  }]\n}",
          "options": {}
        }
      },
      {
        "id": "e2dd7a80-e193-4290-a91b-542eb7f02b52",
        "name": "Parse Compliance Check",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2208,
          -38
        ],
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $('Parse Topic Analysis').first().json;\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, '').replace(/\n?```s*$/, '');\n\ntry {\n  const compliance = JSON.parse(cleaned);\n  return [{\n    json: {\n      headline: prevData.headline,\n      people: prevData.people,\n      teams: prevData.teams,\n      event: prevData.event,\n      imageability: prevData.imageability,\n      imageSuggestion: prevData.imageSuggestion,\n      sourceLink: prevData.sourceLink,\n      compliant: compliance.compliant,\n      complianceReason: compliance.reason,\n      safeImagePrompt: compliance.safeImagePrompt,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  // If parsing fails, mark as non-compliant to be safe\n  return [{\n    json: {\n      ...prevData,\n      compliant: false,\n      complianceReason: 'Parse error: ' + e.message,\n      safeImagePrompt: 'Generic football stadium celebration scene with fans cheering'\n    }\n  }];\n}"
        }
      },
      {
        "id": "2426cf99-5a5b-4963-9ffc-81c4ec3cee01",
        "name": "Aggregate Compliant Topics",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2508,
          -38
        ],
        "parameters": {
          "mode": "runOnceForAllItems",
          "jsCode": "// Collect all items (each article's compliance check result)\nconst items = $input.all();\nconst geminiApiKey = items[0]?.json?.geminiApiKey;\nconst callbackUrl = items[0]?.json?.callbackUrl;\n\n// Filter to only compliant topics and sort by imageability\nconst compliantTopics = items\n  .map(item => item.json)\n  .filter(topic => topic.compliant === true)\n  .sort((a, b) => (b.imageability || 0) - (a.imageability || 0));\n\n// If no compliant topics, create a safe fallback\nif (compliantTopics.length === 0) {\n  return [{\n    json: {\n      selectedTopic: {\n        headline: 'European Football Weekly Update',\n        teams: [],\n        event: 'weekly roundup',\n        safeImagePrompt: 'Exciting football match scene in a packed stadium with cheering fans',\n        sourceLink: '',\n        fallback: true\n      },\n      allTopics: items.map(i => i.json),\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}\n\n// Select the best topic (highest imageability score)\nreturn [{\n  json: {\n    selectedTopic: compliantTopics[0],\n    alternativeTopics: compliantTopics.slice(1, 3),\n    allTopics: items.map(i => i.json),\n    geminiApiKey,\n    callbackUrl\n  }\n}];"
        }
      },
      {
        "id": "hashtag-researcher-1769380010487",
        "name": "Hashtag Researcher",
        "type": "n8n-nodes-base.httpRequest",
        "position": [
          2808,
          -38
        ],
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "authentication": "none",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Find the 3 most relevant, high-reach hashtags for this European football topic.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\n\\nRules:\\n- Return EXACTLY 3 hashtags\\n- Must be real, widely-used hashtags on social media\\n- Must be directly relevant to this specific topic/teams/event\\n- Include the # symbol\\n- Prefer hashtags with high engagement (millions of posts)\\n\\nReturn ONLY a JSON object: {\\\"hashtags\\\": [\\\"#tag1\\\", \\\"#tag2\\\", \\\"#tag3\\\"]}\"\n    }]\n  }]\n}"
        },
        "typeVersion": 4.2
      },
      {
        "id": "parse-hashtags-1769380010487",
        "name": "Parse Hashtags",
        "type": "n8n-nodes-base.code",
        "position": [
          3008,
          -38
        ],
        "parameters": {
          "jsCode": "// Get Gemini response from HTTP Request\nconst geminiResponse = $input.first().json;\n\n// Get original data from Aggregate Compliant Topics (2 nodes back)\nconst originalData = $('Aggregate Compliant Topics').first().json;\nconst geminiApiKey = originalData.geminiApiKey;\nconst callbackUrl = originalData.callbackUrl;\nconst selectedTopic = originalData.selectedTopic;\n\n// Parse hashtags from Gemini response\nlet hashtags = ['#football', '#soccer', '#UEFA']; // fallback\ntry {\n  const candidates = geminiResponse.candidates || [];\n  if (candidates.length > 0) {\n    let text = candidates[0].content?.parts?.[0]?.text || '';\n    text = text.replace(/```json\n?/g, '').replace(/```/g, '').trim();\n    const parsed = JSON.parse(text);\n    if (parsed.hashtags && Array.isArray(parsed.hashtags)) {\n      hashtags = parsed.hashtags.slice(0, 3);\n    }\n  }\n} catch (e) {\n  // Keep fallback\n}\n\nreturn [{\n  json: {\n    selectedTopic: selectedTopic,\n    sourceLink: selectedTopic.sourceLink || '',\n    hashtags: hashtags,\n    hashtagString: hashtags.join(' '),\n    geminiApiKey: geminiApiKey,\n    callbackUrl: callbackUrl\n  }\n}];"
        },
        "typeVersion": 2
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $json.geminiApiKey }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "BilkoBibitkovApp/1.0"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create a short, punchy tagline for a European football social media image.\n\nTOPIC: {{ $json.selectedTopic }}\nPOST PREVIEW: {{ $json.postContent ? $json.postContent.substring(0, 100) : 'Football update' }}\n\nRules:\n- Maximum 4-5 words\n- Catchy and memorable\n- No hashtags\n- Use action words or emotions\n- Should work overlaid on a football image\n\nReturn ONLY a JSON object: {\"tagline\": \"your tagline here\"}\"\n    }]\n  }]\n}",
          "options": {
            "response": {
              "response": {
                "fullResponse": false
              }
            }
          }
        },
        "name": "Generate Tagline",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2600,
          112
        ],
        "id": "tagline-gen-1769390960853"
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Image Prompt\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\n?/, \"\").replace(/\n?```s*$/, \"\");\n\ntry {\n  const taglineData = JSON.parse(cleaned);\n  return [{\n    json: {\n      tagline: taglineData.tagline || \"Game On!\",\n      imagePrompt: prevData.imagePrompt,\n      style: prevData.style,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      tagline: \"Game On!\",\n      imagePrompt: prevData.imagePrompt,\n      style: prevData.style,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      sourceLink: prevData.sourceLink || '',\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Tagline",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2850,
          112
        ],
        "id": "parse-tagline-1769390960853"
      }
    ],
    "connections": {
      "Schedule Trigger": {
        "main": [
          [
            {
              "node": "Merge Triggers",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Webhook": {
        "main": [
          [
            {
              "node": "Merge Triggers",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Merge Triggers": {
        "main": [
          [
            {
              "node": "Fetch RSS",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch RSS": {
        "main": [
          [
            {
              "node": "Parse XML",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse XML": {
        "main": [
          [
            {
              "node": "Extract Articles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Articles": {
        "main": [
          [
            {
              "node": "Topic Analyst",
              "type": "main",
              "index": 0
            },
            {
              "node": "Callback Articles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Post": {
        "main": [
          [
            {
              "node": "Parse Post",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Image": {
        "main": [
          [
            {
              "node": "Parse Image Prompt",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Final Output": {
        "main": [
          [
            {
              "node": "Callback Final",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Callback Final": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call Imagen API": {
        "main": [
          [
            {
              "node": "Parse Imagen Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Imagen Response": {
        "main": [
          [
            {
              "node": "Build Final Output",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Topic Analyst": {
        "main": [
          [
            {
              "node": "Parse Topic Analysis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Topic Analysis": {
        "main": [
          [
            {
              "node": "Compliance Checker",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Compliance Checker": {
        "main": [
          [
            {
              "node": "Parse Compliance Check",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Compliance Check": {
        "main": [
          [
            {
              "node": "Aggregate Compliant Topics",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Aggregate Compliant Topics": {
        "main": [
          [
            {
              "node": "Hashtag Researcher",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Post": {
        "main": [
          [
            {
              "node": "Generate Image",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Image Prompt": {
        "main": [
          [
            {
              "node": "Generate Tagline",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Hashtag Researcher": {
        "main": [
          [
            {
              "node": "Parse Hashtags",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Hashtags": {
        "main": [
          [
            {
              "node": "Generate Post",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Tagline": {
        "main": [
          [
            {
              "node": "Parse Tagline",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Tagline": {
        "main": [
          [
            {
              "node": "Call Imagen API",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Bilko Bibitkov",
    "name": null,
    "description": null,
    "autosaved": false
  }
}
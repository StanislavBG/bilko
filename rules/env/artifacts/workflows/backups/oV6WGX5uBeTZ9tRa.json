{
  "updatedAt": "2026-02-02T04:57:59.603Z",
  "createdAt": "2026-01-25T09:36:24.234Z",
  "id": "oV6WGX5uBeTZ9tRa",
  "name": "[EFD] European Football Daily",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "european-football-daily",
        "responseMode": "onReceived",
        "options": {}
      },
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        0,
        208
      ],
      "id": "0025e044-d2ba-4e9f-8e73-98ca642c1087",
      "webhookId": "191adfc0-b71a-41c2-8a26-25ca9ec0b6c1"
    },
    {
      "parameters": {
        "url": "https://news.google.com/rss/search?q=european+football+champions+league+OR+premier+league+OR+la+liga+OR+bundesliga+OR+serie+a&hl=en-US&gl=US&ceid=US:en",
        "options": {}
      },
      "name": "Fetch RSS",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        512,
        112
      ],
      "id": "a0c4d441-f13a-4003-8f49-1a710d29c12e"
    },
    {
      "parameters": {
        "options": {}
      },
      "name": "Parse XML",
      "type": "n8n-nodes-base.xml",
      "typeVersion": 1,
      "position": [
        752,
        112
      ],
      "id": "9466c9e8-2426-4e44-8a8e-ef37a1138c38"
    },
    {
      "parameters": {
        "jsCode": "const rss = $input.first().json;\nconst webhookData = $('Webhook').first().json.body || {};\nconst recentTopics = webhookData.recentTopics || [];\n\n// Build normalized headline set for exact matching\nconst recentHeadlinesNormalized = new Set(\n  recentTopics.map(t => t.headline.toLowerCase().trim().replace(/[^a-z0-9\\s]/g, ''))\n);\n\nconst items = rss?.rss?.channel?.item || [];\n\n// v2.5.1: SMARTER pre-filter for generic explainers\n// Only skip if: (1) matches question pattern AND (2) has NO data signals\n\n// Patterns that indicate DATA-RICH content (never skip these)\nconst DATA_SIGNALS = [\n  /\\d+-\\d+/,                    // Score patterns: 3-0, 2-1\n  /\\d+:\\d+/,                    // Score patterns: 3:0\n  /[€£$]\\d+/,                  // Transfer fees: €180M\n  /\\d+[mk]\\b/i,               // Money: 180M, 50k\n  /\\d+ (goals?|points?|wins?)/i, // Stats: 10 goals\n  /(beat|defeated|won|lost|drew)/i, // Match results\n  /signs?|transfer|deal|fee/i,      // Transfer news\n];\n\nconst hasDataSignals = (title) => {\n  return DATA_SIGNALS.some(pattern => pattern.test(title));\n};\n\n// Generic explainer patterns (skip only if NO data signals)\nconst GENERIC_PATTERNS = [\n  /^how (can|does|do|will|could|would|should|to) /i,\n  /^what (is|are|does|do|if|to) /i,\n  /^why (is|are|does|do|won't|can't|don't) /i,\n  /^when (is|are|does|do|will|can) /i,\n  /competition format/i,\n  /explained$/i,\n  /^guide:/i,\n  /^understanding /i,\n  /everything you need to know/i\n];\n\nconst isGenericExplainer = (title) => {\n  // If title has data signals (scores, fees, results), NEVER skip\n  if (hasDataSignals(title)) {\n    return false;\n  }\n  // Only skip if matches generic pattern AND has no data\n  return GENERIC_PATTERNS.some(pattern => pattern.test(title.trim()));\n};\n\n// Take up to 50 items, pre-filter generic explainers\nconst preFilteredItems = items.slice(0, 50).filter(item => {\n  const title = item.title || '';\n  return !isGenericExplainer(title);\n});\n\nconst articles = preFilteredItems.map(item => ({\n  title: item.title || '',\n  sourceHeadline: item.title || '',\n  link: item.link || '',\n  source: 'Google News',\n  pubDate: item.pubDate || ''\n})).filter(a => {\n  const normalizedTitle = a.title.toLowerCase().trim().replace(/[^a-z0-9\\s]/g, '');\n  \n  // PRIMARY: Normalized exact headline match\n  if (recentHeadlinesNormalized.has(normalizedTitle)) {\n    return false;\n  }\n  \n  // SECONDARY: Word overlap check (>50% = likely duplicate)\n  const words = new Set(normalizedTitle.split(/\\s+/).filter(w => w.length > 3));\n  if (words.size >= 3) {\n    for (const recent of recentTopics) {\n      const recentNorm = recent.headline.toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n      const recentWords = new Set(recentNorm.split(/\\s+/).filter(w => w.length > 3));\n      if (recentWords.size >= 3) {\n        const overlap = [...words].filter(w => recentWords.has(w)).length;\n        const similarity = overlap / Math.min(words.size, recentWords.size);\n        if (similarity > 0.5) {\n          return false;\n        }\n      }\n    }\n  }\n  \n  return true;\n}).slice(0, 20);\n\n// Fallback if all filtered out\nif (articles.length === 0 && items.length > 0) {\n  const first = items[0];\n  return [{\n    json: {\n      title: first.title || 'European Football Update',\n      sourceHeadline: first.title || 'European Football Update',\n      link: first.link || '',\n      source: 'Google News',\n      pubDate: first.pubDate || '',\n      forcedFallback: true,\n      recentTopicsCount: recentTopics.length\n    }\n  }];\n}\n\nreturn articles.map(a => ({ \n  json: { \n    ...a, \n    recentTopicsCount: recentTopics.length,\n    preFilterVersion: '2.5.1'\n  } \n}));"
      },
      "name": "Extract Articles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        112
      ],
      "id": "2a98ef6a-8bc2-4312-9ae1-9c72f99e4b84"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"extract-articles\",\n  \"stepIndex\": 1,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"articles\": {{ JSON.stringify($input.all().map(i => i.json)) }},\n    \"count\": {{ $input.all().length }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
        "options": {}
      },
      "name": "Callback Articles",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1104,
        256
      ],
      "id": "c6ed77f1-fb89-4efe-875f-2c7668fa7140"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $input.first().json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.geminiRequestBody) }}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "name": "Generate Post",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2816,
        -32
      ],
      "id": "7c494835-fa77-48c9-ae73-269be50bb6af",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Hashtags\").first().json;\n\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Remove markdown code fences - handle both ```json and ``` at start/end\nlet cleaned = text.trim();\nif (cleaned.startsWith('```')) {\n  // Remove opening fence (```json or ```)\n  cleaned = cleaned.replace(/^```[a-zA-Z]*\\s*/, '');\n}\nif (cleaned.endsWith('```')) {\n  // Remove closing fence\n  cleaned = cleaned.replace(/\\s*```$/, '');\n}\ncleaned = cleaned.trim();\n\ntry {\n  const post = JSON.parse(cleaned);\n  let postContent = post.postContent || \"\";\n  \n  // Get source URLs - fallback to sourceLink if sourceUrls is empty\n  let sourceUrls = prevData.sourceUrls || [];\n  const sourceLink = prevData.sourceLink || prevData.selectedTopic?.sourceLink;\n  \n  // If sourceUrls is empty but we have sourceLink, use it\n  if (sourceUrls.length === 0 && sourceLink) {\n    sourceUrls = [{ url: sourceLink, title: \"Source\" }];\n  }\n  \n  // Add source citations at the end (before hashtags)\n  if (sourceUrls.length > 0) {\n    // Find where hashtags start (# followed by word)\n    const hashtagMatch = postContent.match(/#[A-Za-z]/);\n    let beforeHashtags = postContent;\n    let hashtags = \"\";\n    \n    if (hashtagMatch) {\n      const hashtagIndex = postContent.indexOf(hashtagMatch[0]);\n      beforeHashtags = postContent.slice(0, hashtagIndex).trim();\n      hashtags = postContent.slice(hashtagIndex).trim();\n    }\n    \n    // Build citation line with numbered hyperlinks\n    const citations = sourceUrls.map((s, i) => \n      \"[\" + (i + 1) + \"](\" + s.url + \")\"\n    ).join(\" \");\n    \n    // Reconstruct post with sources\n    postContent = beforeHashtags + \"\\n\\nSources: \" + citations + \"\\n\\n\" + hashtags;\n  }\n  \n  return [{\n    json: {\n      postContent: postContent,\n      sentiment: post.sentiment || \"neutral\",\n      statsHighlighted: post.statsHighlighted || [],\n      safeImagePrompt: prevData.selectedTopic?.safeImagePrompt,\n      anonymizedDescriptions: prevData.selectedTopic?.anonymizedDescriptions || prevData.anonymizedDescriptions || {},\n      selectedTopic: prevData.selectedTopic,\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      extractedStats: prevData.extractedStats || {},\n      teams: prevData.teams,\n      competition: prevData.competition,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  // Get source URLs - fallback to sourceLink if sourceUrls is empty\n  let sourceUrls = prevData.sourceUrls || [];\n  const sourceLink = prevData.sourceLink || prevData.selectedTopic?.sourceLink;\n  \n  // If sourceUrls is empty but we have sourceLink, use it\n  if (sourceUrls.length === 0 && sourceLink) {\n    sourceUrls = [{ url: sourceLink, title: \"Source\" }];\n  }\n  \n  const citations = sourceUrls.map((s, i) => \"[\" + (i + 1) + \"](\" + s.url + \")\").join(\" \");\n  \n  return [{\n    json: {\n      postContent: \"Football news update! Exciting developments in European football today.\\n\\nSources: \" + citations,\n      sentiment: \"neutral\",\n      statsHighlighted: [],\n      safeImagePrompt: prevData.selectedTopic?.safeImagePrompt || \"Exciting football stadium scene\",\n      anonymizedDescriptions: prevData.selectedTopic?.anonymizedDescriptions || {},\n      selectedTopic: prevData.selectedTopic,\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      extractedStats: prevData.extractedStats || {},\n      teams: prevData.teams,\n      competition: prevData.competition,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message,\n      rawText: text.substring(0, 200)\n    }\n  }];\n}\n"
      },
      "name": "Parse Post",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        112
      ],
      "id": "5ffc1c44-ad8f-4df3-bb2c-2ac5ec931d9f"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $input.first().json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "fb8ce752-bb66-4d73-abb2-24fad043a177",
      "name": "Generate Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2256,
        112
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Post\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const imageData = JSON.parse(cleaned);\n  return [{\n    json: {\n      imagePrompt: imageData.imagePrompt,\n      style: imageData.style || \"photorealistic\",\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      imagePrompt: \"Exciting football celebration scene in a modern stadium\",\n      style: \"photorealistic\",\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Image Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2512,
        112
      ],
      "id": "654ab797-28bc-4e88-a66c-74887fbedae5"
    },
    {
      "parameters": {
        "jsCode": "const brandingResult = $input.first().json;\n\nconst postContent = brandingResult.postContent || \"Football news update!\";\nconst imagePrompt = brandingResult.imagePrompt || \"European football celebration\";\nconst sourceLink = brandingResult.sourceLink || \"\";\nconst extractedStats = brandingResult.extractedStats || {};\nconst selectedTopic = brandingResult.selectedTopic || {};\nconst sourceUrls = brandingResult.sourceUrls || [];\nconst comprehensiveSummary = brandingResult.comprehensiveSummary || \"\";\nconst keyFacts = brandingResult.keyFacts || [];\nconst infographicElements = brandingResult.infographicElements || [];\n\nlet imageDataUri = brandingResult.imageDataUri || null;\nif (brandingResult.success && brandingResult.brandedImageBase64) {\n  imageDataUri = \"data:image/png;base64,\" + brandingResult.brandedImageBase64;\n}\n\n// Build source citations for transparency post\nconst citations = sourceUrls.map((s, i) => \"[\" + (i + 1) + \"] \" + s.url).join(\"\\n\");\n\nlet transparencyPost = \"I've developed this AI-driven system to efficiently curate European football news, serving as a professional 'proof of work' for AI integration. Grounded in transparency and the human-in-the-loop principle, this project demonstrates how AI can enhance specialized content. Follow for updates, or visit my bio to learn how to build similar systems.\\n\\nBilko Bibitkov Human-Centric AI Curation\\n\\n\" + brandingResult.sourceCount + \" sources analyzed for this report.\";\n\nif (citations) {\n  transparencyPost += \"\\n\\nSources:\\n\" + citations;\n}\n\nconst output = {\n  success: true,\n  selectedTopic: {\n    headline: selectedTopic.headline || \"\",\n    sourceHeadline: selectedTopic.sourceHeadline || selectedTopic.headline || \"\",\n    sourceHeadlineHash: selectedTopic.sourceHeadlineHash || \"\",\n    teams: selectedTopic.teams || [],\n    event: selectedTopic.event || \"\",\n    dataRichness: extractedStats.dataConfidence || selectedTopic.dataRichness || 0,\n    brandValue: selectedTopic.brandValue || 0,\n    extractedStats: extractedStats,\n    eventSummary: brandingResult.eventSummary || \"\"\n  },\n  data: {\n    postContent: postContent,\n    comprehensiveSummary: comprehensiveSummary,\n    keyFacts: keyFacts,\n    imagePrompt: imagePrompt,\n    imageUrl: imageDataUri,\n    eventSummary: brandingResult.eventSummary || \"\",\n    infographicElements: infographicElements,\n    transparencyPost: transparencyPost,\n    sourceLink: sourceLink,\n    sourceUrls: sourceUrls,\n    sourceCount: brandingResult.sourceCount || 1,\n    contentFiltered: !imageDataUri\n  }\n};\n\nreturn [{ json: output }];"
      },
      "name": "Build Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        112
      ],
      "id": "71b64e2c-1852-4ef6-a21d-732907892df3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"final-output\",\n  \"stepIndex\": 3,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {{ JSON.stringify($input.first().json) }},\n  \"executionId\": \"{{ $execution.id }}\"\n}",
        "options": {}
      },
      "name": "Callback Final",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3008,
        112
      ],
      "id": "5a99a7c6-1f47-47eb-a13d-888ae0334bcf"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $('Build Final Output').first().json }}",
        "options": {}
      },
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        3264,
        208
      ],
      "id": "4ea89a64-7267-4476-aac6-d67c10a7da98"
    },
    {
      "parameters": {
        "content": "PRODUCTION"
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        416,
        496
      ],
      "id": "303bff0e-4feb-4c29-903e-cd2782ab38ba",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"{{ $json.imagePrompt }}. Include bold stylized text overlay on the image saying: {{ $json.eventSummary }}\"\n    }]\n  }],\n  \"generation_config\": {\n    \"response_modalities\": [\"IMAGE\"],\n    \"image_config\": {\n      \"aspect_ratio\": \"1:1\"\n    }\n  }\n}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "74affa50-0102-49a6-8190-3e24f1ec0a2e",
      "name": "Call Imagen API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3104,
        112
      ],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Event Summary\").first().json;\n\nconst parts = input?.candidates?.[0]?.content?.parts || [];\nconst imagePart = parts.find(p => p.inlineData?.mimeType?.startsWith(\"image/\"));\n\nif (imagePart && imagePart.inlineData?.data) {\n  const mimeType = imagePart.inlineData.mimeType;\n  const base64Data = imagePart.inlineData.data;\n  const imageDataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n\n  return [{\n    json: {\n      imageDataUri: imageDataUri,\n      imagePrompt: prevData.imagePrompt,\n      eventSummary: prevData.eventSummary,\n      infographicElements: prevData.infographicElements,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: prevData.sourceLink,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} else {\n  return [{\n    json: {\n      imageDataUri: null,\n      imagePrompt: prevData.imagePrompt,\n      eventSummary: prevData.eventSummary,\n      infographicElements: prevData.infographicElements,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: prevData.sourceLink,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      imagenError: \"No image data in response\"\n    }\n  }];\n}"
      },
      "id": "ec694419-9c45-4f5d-b2a9-56f136492315",
      "name": "Parse Imagen Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3360,
        112
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Analyze this football news headline and extract key information for social media.\\n\\nHEADLINE: {{ $json.title }}\\n\\nReturn ONLY a JSON object with:\\n- headline: the original headline\\n- teams: array of team names mentioned (prioritize big clubs: Real Madrid, Barcelona, Man City, Liverpool, Bayern, PSG, Juventus, etc.)\\n- event: brief description (match result, transfer, injury, etc.)\\n- hasScore: boolean - true if headline contains a match score like 3-0, 2-1\\n- hasNumbers: boolean - true if contains significant numbers (transfer fees, goals, points, positions)\\n- dataRichness: score 1-10 (10=has scores/stats/numbers, 5=has team names, 1=vague/generic)\\n- brandValue: score 1-10 (10=mentions top clubs/leagues/tournaments, 1=unknown teams)\\n- imageability: score 1-10 how easy to create a generic image\\n- imageSuggestion: a generic image concept avoiding real people names\\n\\nPrioritize headlines with: actual scores, transfer fees, league standings, big club names.\\nExample: { \\\"headline\\\": \\\"Barcelona 3-0 Real Madrid\\\", \\\"teams\\\": [\\\"Barcelona\\\", \\\"Real Madrid\\\"], \\\"event\\\": \\\"El Clasico victory\\\", \\\"hasScore\\\": true, \\\"hasNumbers\\\": true, \\\"dataRichness\\\": 10, \\\"brandValue\\\": 10, \\\"imageability\\\": 9, \\\"imageSuggestion\\\": \\\"celebrating football team in red and blue\\\" }\"\n    }]\n  }]\n}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 2000
            }
          }
        },
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "3bcffc23-1424-49a1-afd7-7f0514ed2ef7",
      "name": "Topic Analyst",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1312,
        -32
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst geminiApiKey = $(\"Webhook\").first().json.body.geminiApiKey;\nconst callbackUrl = $(\"Webhook\").first().json.body.callbackUrl;\n\n// Get the source article data from Extract Articles using item index\nconst articleItems = $(\"Extract Articles\").all();\nconst currentIndex = $runIndex;\nconst articleData = articleItems[currentIndex]?.json || {};\nconst sourceLink = articleData.link || \"\";\nconst sourceHeadline = articleData.sourceHeadline || articleData.title || \"\";\nconst sourceHeadlineHash = articleData.titleHash || \"\";\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const analysis = JSON.parse(cleaned);\n  return [{\n    json: {\n      ...analysis,\n      sourceLink: sourceLink,\n      sourceHeadline: sourceHeadline,\n      sourceHeadlineHash: sourceHeadlineHash,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      headline: \"Football news update\",\n      people: [],\n      teams: [],\n      event: \"general news\",\n      imageability: 5,\n      imageSuggestion: \"generic football stadium scene\",\n      sourceLink: sourceLink,\n      sourceHeadline: sourceHeadline,\n      sourceHeadlineHash: sourceHeadlineHash,\n      parseError: e.message,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}"
      },
      "id": "4a292d0b-d120-4074-87fc-6667de4e4de6",
      "name": "Parse Topic Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        -32
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 2000
            }
          }
        },
        "contentType": "json",
        "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "9c51724e-f9eb-4bea-a72c-3dbf6c163d0a",
      "name": "Compliance Checker",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1920,
        -32
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Topic Analysis\").first().json;\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const compliance = JSON.parse(cleaned);\n  return [{\n    json: {\n      headline: prevData.headline,\n      people: prevData.people,\n      teams: prevData.teams,\n      event: prevData.event,\n      imageability: prevData.imageability,\n      imageSuggestion: prevData.imageSuggestion,\n      sourceLink: prevData.sourceLink,\n      sourceHeadline: prevData.sourceHeadline,\n      sourceHeadlineHash: prevData.sourceHeadlineHash,\n      compliant: compliance.compliant !== false,\n      complianceReason: compliance.reason,\n      anonymizedDescriptions: compliance.anonymizedDescriptions || {},\n      safeImagePrompt: compliance.safeImagePrompt,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ...prevData,\n      compliant: true,\n      complianceReason: \"Parse error, using fallback: \" + e.message,\n      anonymizedDescriptions: {},\n      safeImagePrompt: \"Generic football stadium celebration scene with fans cheering\"\n    }\n  }];\n}"
      },
      "id": "e2dd7a80-e193-4290-a91b-542eb7f02b52",
      "name": "Parse Compliance Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2208,
        -32
      ]
    },
    {
      "parameters": {
        "jsCode": "// Collect all items (each article's compliance check result)\nconst items = $input.all();\nconst geminiApiKey = items[0]?.json?.geminiApiKey;\nconst callbackUrl = items[0]?.json?.callbackUrl;\n\n// Filter to only compliant topics and sort by data-richness + brand value\nconst compliantTopics = items\n  .map(item => item.json)\n  .filter(topic => topic.compliant === true)\n  .sort((a, b) => {\n    // Combined score prioritizing data-rich, high-brand topics\n    const scoreA = (a.dataRichness || 0) * 2 + (a.brandValue || 0) * 1.5 + (a.imageability || 0);\n    const scoreB = (b.dataRichness || 0) * 2 + (b.brandValue || 0) * 1.5 + (b.imageability || 0);\n    return scoreB - scoreA;\n  });\n\n// If no compliant topics, create a safe fallback\nif (compliantTopics.length === 0) {\n  return [{\n    json: {\n      selectedTopic: {\n        headline: 'European Football Weekly Update',\n        teams: [],\n        event: 'weekly roundup',\n        safeImagePrompt: 'Exciting football match scene in a packed stadium with cheering fans',\n        anonymizedDescriptions: {},\n        fallback: true\n      },\n      allTopics: items.map(i => i.json),\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}\n\n// Select the best topic (highest combined score)\nreturn [{\n  json: {\n    selectedTopic: compliantTopics[0],\n    alternativeTopics: compliantTopics.slice(1, 3),\n    allTopics: items.map(i => i.json),\n    geminiApiKey,\n    callbackUrl\n  }\n}];"
      },
      "id": "2426cf99-5a5b-4963-9ffc-81c4ec3cee01",
      "name": "Aggregate Compliant Topics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2512,
        -32
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $json.geminiApiKey }}"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Find the 3 most relevant, high-reach hashtags for this European football topic.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\nKEY DATA: {{ $json.selectedTopic?.extractedStats?.keyStatistic || 'general football news' }}\\n\\nRules:\\n- Return EXACTLY 3 hashtags\\n- Must be real, widely-used hashtags on social media\\n- Must be directly relevant to this specific topic/teams/event\\n- Include the # symbol\\n- Prefer hashtags with high engagement (millions of posts)\\n\\nReturn ONLY a JSON object: {\\\"hashtags\\\": [\\\"#tag1\\\", \\\"#tag2\\\", \\\"#tag3\\\"]}\"\n    }]\n  }]\n}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "id": "hashtag-researcher-1769380010487",
      "name": "Hashtag Researcher",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        2816,
        -32
      ],
      "typeVersion": 4.2,
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get Gemini response from HTTP Request\nconst geminiResponse = $input.first().json;\n\n// Get original data from Aggregate Compliant Topics or Parse Statistics (whichever is available)\nlet originalData;\ntry {\n  originalData = $(\"Parse Statistics\").first().json;\n} catch (e) {\n  try {\n    originalData = $(\"Aggregate Compliant Topics\").first().json;\n  } catch (e2) {\n    originalData = {};\n  }\n}\n\nconst geminiApiKey = originalData.geminiApiKey;\nconst callbackUrl = originalData.callbackUrl;\nconst selectedTopic = originalData.selectedTopic || {};\nconst extractedStats = selectedTopic.extractedStats || originalData.extractedStats || {};\nconst teams = selectedTopic.teams || [];\nconst competition = selectedTopic.competition || \"\";\nconst sourceUrls = originalData.sourceUrls || [];\nconst sourceCount = originalData.sourceCount || 1;\n\n// Parse hashtags from Gemini response\nlet hashtags = [\"#football\", \"#soccer\", \"#UEFA\"]; // fallback\ntry {\n  const candidates = geminiResponse.candidates || [];\n  if (candidates.length > 0) {\n    let text = candidates[0].content?.parts?.[0]?.text || \"\";\n    text = text.replace(/```json\\n?/g, \"\").replace(/```/g, \"\").trim();\n    const parsed = JSON.parse(text);\n    if (parsed.hashtags && Array.isArray(parsed.hashtags)) {\n      hashtags = parsed.hashtags.slice(0, 3);\n    }\n  }\n} catch (e) {\n  // Keep fallback\n}\n\nreturn [{\n  json: {\n    selectedTopic: selectedTopic,\n    extractedStats: extractedStats,\n    teams: teams,\n    competition: competition,\n    sourceUrls: sourceUrls,\n    sourceCount: sourceCount,\n    sourceLink: selectedTopic?.sourceLink || \"\",\n    anonymizedDescriptions: selectedTopic?.anonymizedDescriptions || {},\n    hashtags: hashtags,\n    hashtagString: hashtags.join(\" \"),\n    geminiApiKey: geminiApiKey,\n    callbackUrl: callbackUrl\n  }\n}];"
      },
      "id": "parse-hashtags-1769380010487",
      "name": "Parse Hashtags",
      "type": "n8n-nodes-base.code",
      "position": [
        3008,
        -32
      ],
      "typeVersion": 2
    },
    {
      "id": "prepare-post-request-1769980000001",
      "name": "Prepare Post Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2750,
        -32
      ],
      "parameters": {
        "jsCode": "// Sanitize content for JSON serialization\nconst prevData = $input.first().json;\nconst selectedTopic = prevData.selectedTopic || {};\nconst extractedStats = prevData.extractedStats || selectedTopic.extractedStats || {};\nconst teams = prevData.teams || selectedTopic.teams || [];\nconst competition = prevData.competition || selectedTopic.competition || '';\nconst hashtagString = prevData.hashtagString || '#football #soccer #UEFA';\nconst sourceCount = prevData.sourceCount || 1;\nconst keyFacts = prevData.keyFacts || [];\n\n// Sanitize function - remove characters that break JSON\nconst sanitize = (str) => {\n  if (typeof str !== 'string') return String(str || '');\n  return str\n    .replace(/[\\x00-\\x1F\\x7F]/g, ' ')\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\"/g, \"'\")\n    .replace(/\\n/g, ' ')\n    .substring(0, 2000)\n    .trim();\n};\n\n// Build sanitized values\nconst headline = sanitize(selectedTopic.headline || 'Football news');\nconst comprehensiveSummary = sanitize(prevData.comprehensiveSummary || 'Football update');\nconst teamsStr = sanitize(teams.join(', '));\nconst competitionStr = sanitize(competition);\nconst keyFactsStr = sanitize(keyFacts.slice(0, 3).join('; '));\n\n// Build the prompt\nconst promptText = `You are an objective European football journalist creating a comprehensive Facebook post.\n\nTOPIC: ${headline}\nCOMPREHENSIVE SUMMARY: ${comprehensiveSummary}\nTEAMS: ${teamsStr}\nCOMPETITION: ${competitionStr}\nHASHTAGS TO USE: ${hashtagString}\n\nEXTRACTED STATISTICS:\n- Score: ${extractedStats.score || 'not available'}\n- Possession: Home ${extractedStats.possession?.home || '?'}% - Away ${extractedStats.possession?.away || '?'}%\n- Shots: Home ${extractedStats.shots?.home || '?'} - Away ${extractedStats.shots?.away || '?'}\n- Transfer Fee: ${extractedStats.transferFee || 'N/A'}\n- League Position: ${extractedStats.leaguePosition || 'N/A'}\n- Points: ${extractedStats.points || 'N/A'}\n\nKEY FACTS: ${keyFactsStr}\nSOURCE COUNT: ${sourceCount} sources analyzed\n\nCreate an OBJECTIVE journalism-style Facebook post (3-4 paragraphs) that:\n1. LEADS with the most significant statistic or result\n2. Presents facts neutrally without bias toward any team\n3. Includes ALL available statistics naturally in the narrative\n4. Provides context about implications for the league/tournament\n5. Uses measured language - avoid superlatives and hype\n6. MUST end with these EXACT hashtags: ${hashtagString}\n\nReturn ONLY a JSON object with:\n- postContent: the full post text including hashtags\n- sentiment: positive/neutral/negative\n- statsHighlighted: array of stats you included`;\n\n// Build Gemini request body\nconst requestBody = {\n  contents: [{\n    parts: [{\n      text: promptText\n    }]\n  }]\n};\n\nreturn [{\n  json: {\n    geminiRequestBody: requestBody,\n    selectedTopic: selectedTopic,\n    extractedStats: extractedStats,\n    teams: teams,\n    competition: competition,\n    hashtagString: hashtagString,\n    sourceUrls: prevData.sourceUrls || [],\n    sourceCount: sourceCount,\n    sourceLink: prevData.sourceLink || selectedTopic.sourceLink || '',\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}];"
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "BilkoBibitkovApp/1.0"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\"contents\":[{\"parts\":[{\"text\":\"Create a PUNCHY, INFORMATIVE headline for a sports infographic overlay.\\n\\nTOPIC: {{ $json.selectedTopic?.headline }}\\nSCORE: {{ $json.extractedStats?.score || 'N/A' }}\\nTEAMS: {{ $json.selectedTopic?.teams?.join(' vs ') || 'N/A' }}\\nCOMPETITION: {{ $json.selectedTopic?.competition || 'European Football' }}\\nTRANSFER FEE: {{ $json.extractedStats?.transferFee || 'N/A' }}\\n\\nCreate a headline that:\\n1. Is 8-13 WORDS (punchy but informative)\\n2. Names the teams/players and includes key context\\n3. Leaves detailed numbers for separate stat overlays\\n4. NO generic phrases: 'Game On', 'What A Match', 'Breaking News'\\n\\nGOOD EXAMPLES (8-13 words):\\n- \\\"Barcelona crush Real Madrid 3-0 in dominant El Clásico victory\\\"\\n- \\\"Manchester City clinch Premier League title with two games remaining\\\"\\n- \\\"Mbappé seals record-breaking move to Real Madrid\\\"\\n- \\\"Liverpool surge to top after thrilling Chelsea win at Anfield\\\"\\n\\nBAD EXAMPLES (PROHIBITED):\\n- \\\"Barcelona defeated Real Madrid 3-0 in El Clásico with Lewandowski scoring twice and the team dominating possession\\\" (too long)\\n- \\\"Game On!\\\" (generic, no facts)\\n- \\\"Big Match Results\\\" (vague)\\n\\nReturn ONLY JSON: { \\\"eventSummary\\\": \\\"your 8-13 word headline here\\\" }\"}]}]}",
        "options": {
          "response": {
            "response": {}
          }
        },
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "name": "Generate Event Summary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2608,
        112
      ],
      "id": "tagline-gen-1769390960853",
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Build Image Request\").first().json;\n\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const taglineData = JSON.parse(cleaned);\n  return [{\n    json: {\n      eventSummary: taglineData.eventSummary || \"Match Report\",\n      imagePrompt: prevData.imagePrompt,\n      infographicElements: prevData.infographicElements,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: prevData.sourceLink,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  // Generate fallback tagline from stats\n  let fallbackTagline = \"Match Report\";\n  if (prevData.extractedStats?.score) {\n    fallbackTagline = prevData.extractedStats.score + \" Final\";\n  } else if (prevData.extractedStats?.transferFee) {\n    fallbackTagline = prevData.extractedStats.transferFee + \" Deal\";\n  } else if (prevData.extractedStats?.leaguePosition) {\n    fallbackTagline = \"#\" + prevData.extractedStats.leaguePosition + \" Ranking\";\n  }\n  \n  return [{\n    json: {\n      eventSummary: fallbackTagline,\n      imagePrompt: prevData.imagePrompt,\n      infographicElements: prevData.infographicElements,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: prevData.sourceLink,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Event Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2864,
        112
      ],
      "id": "parse-tagline-1769390960853"
    },
    {
      "id": "brand-image-node-1769619318863",
      "name": "Brand Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3580,
        112
      ],
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/images/brand",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ imageBase64: $json.imageDataUri ? $json.imageDataUri.replace(/^data:image\\/[^;]+;base64,/, \"\") : null }) }}",
        "options": {}
      }
    },
    {
      "id": "parse-brand-node-1769619318863",
      "name": "Parse Brand Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3800,
        112
      ],
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Imagen Response\").first().json;\n\n// Our /api/images/brand endpoint returns: { success, brandedImageBase64, ... }\n// NOT Gemini format (candidates[].content.parts[])\nlet brandedImageBase64 = null;\n\nif (input.success && input.brandedImageBase64) {\n  // Direct response from our Replit branding endpoint\n  brandedImageBase64 = input.brandedImageBase64;\n} else if (input?.candidates?.[0]?.content?.parts) {\n  // Fallback: Gemini API format (if we ever switch back)\n  const parts = input.candidates[0].content.parts;\n  const imagePart = parts.find(p => p.inlineData?.mimeType?.startsWith(\"image/\"));\n  if (imagePart && imagePart.inlineData?.data) {\n    brandedImageBase64 = imagePart.inlineData.data;\n  }\n}\n\nreturn [{\n  json: {\n    success: !!brandedImageBase64,\n    brandedImageBase64: brandedImageBase64,\n    brandingError: !brandedImageBase64 ? (input.error || 'No branded image in response') : null,\n    imageDataUri: prevData.imageDataUri,\n    imagePrompt: prevData.imagePrompt,\n    eventSummary: prevData.eventSummary,\n    infographicElements: prevData.infographicElements,\n    postContent: prevData.postContent,\n    selectedTopic: prevData.selectedTopic,\n    extractedStats: prevData.extractedStats || {},\n    comprehensiveSummary: prevData.comprehensiveSummary,\n    keyFacts: prevData.keyFacts,\n    sourceUrls: prevData.sourceUrls,\n    sourceCount: prevData.sourceCount,\n    sourceLink: prevData.sourceLink,\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}];"
      }
    },
    {
      "id": "cc_body_builder",
      "name": "Build Compliance Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1620,
        -32
      ],
      "parameters": {
        "jsCode": "// Build the Gemini API request body for compliance checking\nconst headline = $input.first().json.headline;\nconst people = $input.first().json.people || [];\nconst imageSuggestion = $input.first().json.imageSuggestion;\nconst geminiApiKey = $input.first().json.geminiApiKey;\nconst runIndex = $input.first().json.runIndex;\nconst link = $input.first().json.link;\n\nconst prompt = `You are an AI image compliance expert. Analyze this football topic and create anonymous visual descriptions.\n\nTOPIC: ${headline}\nPEOPLE: ${JSON.stringify(people)}\nIMAGE IDEA: ${imageSuggestion}\n\nFor each person listed, generate an anonymous physical description (height, build, hair, attire) without using their name.\n\nReturn ONLY valid JSON with these fields:\n- compliant: true\n- reason: why its safe for image generation  \n- anonymizedDescriptions: object mapping each person name to their anonymous description\n- safeImagePrompt: the image prompt rewritten with anonymous descriptions`;\n\nreturn {\n  json: {\n    headline,\n    people,\n    imageSuggestion,\n    geminiApiKey,\n    runIndex,\n    link,\n    requestBody: {\n      contents: [{\n        parts: [{ text: prompt }]\n      }]\n    }\n  }\n};\n"
      }
    },
    {
      "id": "gi_body_builder",
      "name": "Build Image Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2006,
        112
      ],
      "parameters": {
        "jsCode": "const prevData = $input.first().json;\nconst selectedTopic = prevData.selectedTopic || {};\nconst extractedStats = prevData.extractedStats || {};\nconst keyFacts = prevData.keyFacts || [];\nconst sourceCount = prevData.sourceCount || 1;\nconst teams = selectedTopic.teams || [];\n\n// WALLPAPER-FIRST DESIGN: Prioritize cinematic scene with minimal overlays\n// Select only 2-3 MOST IMPACTFUL stats (not all of them)\nconst statPriority = [];\n\n// Priority 1: Score (most important for match results)\nif (extractedStats.score) {\n  statPriority.push({\n    type: 'score',\n    value: extractedStats.score,\n    display: extractedStats.score\n  });\n}\n\n// Priority 2: Transfer fee (for transfer news)\nif (extractedStats.transferFee && !extractedStats.score) {\n  statPriority.push({\n    type: 'transfer',\n    value: extractedStats.transferFee,\n    display: extractedStats.transferFee\n  });\n}\n\n// Priority 3: League position (for standings news)\nif (extractedStats.leaguePosition && statPriority.length < 2) {\n  const ordinal = extractedStats.leaguePosition + (['st','nd','rd'][((extractedStats.leaguePosition+90)%100-10)%10-1]||'th');\n  statPriority.push({\n    type: 'position',\n    value: extractedStats.leaguePosition,\n    display: ordinal + ' Place'\n  });\n}\n\n// Priority 4: Possession (visual stat for match)\nif (extractedStats.possession?.home && statPriority.length < 2) {\n  statPriority.push({\n    type: 'possession',\n    value: extractedStats.possession.home,\n    display: extractedStats.possession.home + '% Possession'\n  });\n}\n\n// Priority 5: Points (if league standings)\nif (extractedStats.points && statPriority.length < 2) {\n  statPriority.push({\n    type: 'points',\n    value: extractedStats.points,\n    display: extractedStats.points + ' pts'\n  });\n}\n\n// Allow 1-5 stat overlays based on data richness\n// dataRichness is from Topic Analyst (selectedTopic), not extractedStats\nconst dataRichness = selectedTopic.dataRichness || extractedStats.dataConfidence || 3;\n// REDUCED from 5 to 3 max overlays for cleaner visual aesthetic\n// High dataRichness still gets 2-3 overlays, but never more\nconst maxOverlays = Math.min(3, Math.max(1, Math.ceil(dataRichness / 3)));\nconst selectedStats = statPriority.slice(0, maxOverlays);\n\n// Build team color context\n// Build team logo instruction for image\nconst teamLogos = teams.length > 0\n  ? 'Include stylized logos or emblems representing: ' + teams.join(', ') + '.'\n  : 'Include relevant league/competition branding.';\n\nconst teamColors = teams.length >= 2 \n  ? 'colors inspired by ' + teams[0] + ' and ' + teams[1]\n  : teams.length === 1 \n    ? 'colors inspired by ' + teams[0]\n    : 'deep blue and gold accents';\n\n// Determine scene type based on news category\nlet sceneType = 'epic stadium atmosphere at golden hour';\nif (extractedStats.transferFee) {\n  sceneType = 'dramatic press conference lighting with stadium silhouette in background';\n} else if (extractedStats.leaguePosition) {\n  sceneType = 'trophy room with championship memorabilia, dramatic spotlight';\n} else if (extractedStats.score) {\n  sceneType = 'packed stadium celebrating, flares and confetti, wide cinematic angle';\n}\n\n// WALLPAPER-FIRST prompt structure\nlet fullPrompt = 'Create a CINEMATIC DESKTOP WALLPAPER image (16:9 aspect ratio). ';\nfullPrompt += 'Primary focus: ' + sceneType + '. ';\nfullPrompt += 'Style: High-end sports broadcast quality, dramatic lighting, ' + teamColors + '. ';\nfullPrompt += 'Composition: 70% atmospheric scene, 30% clean negative space for optional text overlay. ';\nfullPrompt += 'Aesthetic: Premium, immersive, like a movie poster or AAA game cover. ';\n\n// Add MINIMAL stat overlays (2 max)\nif (selectedStats.length > 0) {\n  const overlays = selectedStats.map(s => {\n    if (s.type === 'score') {\n      return 'SCORE: \"' + s.display + '\" - large, elegant typography in lower third';\n    } else if (s.type === 'transfer') {\n      return 'FEE BADGE: \"' + s.display + '\" - gold accent, corner placement';\n    } else if (s.type === 'position') {\n      return 'RANK: \"' + s.display + '\" - subtle, integrated into scene';\n    } else if (s.type === 'possession') {\n      return 'STAT: \"' + s.display + '\" - thin bar graphic, bottom edge';\n    } else if (s.type === 'points') {\n      return 'POINTS: \"' + s.display + '\" - small badge, corner';\n    }\n    return '';\n  }).filter(Boolean);\n  \n  fullPrompt += 'Minimal overlays: ' + overlays.join('. ') + '. ';\n} else {\n  fullPrompt += 'No text overlays - pure atmospheric image. ';\n}\n\nfullPrompt += 'CRITICAL: NO faces, NO real people, NO player likenesses. Focus on atmosphere, stadium, crowd energy, abstract team elements. ';\nfullPrompt += 'Quality: 4K desktop wallpaper, sharp details, professional color grading.';\n\nconst requestBody = {\n  contents: [{\n    parts: [{\n      text: fullPrompt\n    }]\n  }]\n};\n\nreturn [{\n  json: {\n    requestBody,\n    imagePrompt: fullPrompt,\n    selectedStats: selectedStats,\n    sceneType: sceneType,\n    postContent: prevData.postContent,\n    selectedTopic: prevData.selectedTopic,\n    extractedStats: extractedStats,\n    comprehensiveSummary: prevData.comprehensiveSummary,\n    keyFacts: keyFacts,\n    sourceUrls: prevData.sourceUrls,\n    sourceCount: sourceCount,\n    sourceLink: prevData.sourceLink,\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}];"
      }
    },
    {
      "id": "fetch-article-content-1769975476415",
      "name": "Fetch Article Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2600,
        -150
      ],
      "parameters": {
        "method": "GET",
        "url": "={{ $json.selectedTopic.sourceLink }}",
        "options": {
          "redirect": {
            "redirect": {
              "followRedirects": true,
              "maxRedirects": 5
            }
          },
          "response": {
            "response": {
              "responseFormat": "text"
            }
          },
          "timeout": 15000
        }
      },
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 2000
    },
    {
      "id": "prepare-stats-request-1769980000000",
      "name": "Prepare Stats Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2675,
        -150
      ],
      "parameters": {
        "jsCode": "// Get merged content from source collection\nconst mergedData = $input.first().json;\nconst selectedTopic = mergedData.selectedTopic || {};\n\n// Use the combined articles text from all sources\nlet rawContent = mergedData?.articlesText || \"No content available\";\n\n// Sanitize content for JSON\nrawContent = rawContent\n  .replace(/[\\x00-\\x1F\\x7F]/g, \" \")\n  .replace(/\\\\n/g, \" \")\n  .replace(/\\n/g, \" \")\n  .replace(/\\r/g, \" \")\n  .replace(/\\t/g, \" \")\n  .replace(/\\\\/g, \" \")\n  .replace(/\"/g, \"'\")\n  .substring(0, 8000)\n  .trim();\n\nconst sourceCount = mergedData.sourceCount || 1;\n\n// Build the prompt text\nconst promptText = `Extract SPECIFIC STATISTICS from these football articles. Look for:\n\n1. MATCH SCORES (e.g., 3-0, 2-1)\n2. POSSESSION PERCENTAGES\n3. SHOT COUNTS\n4. TRANSFER FEES (in millions)\n5. LEAGUE STANDINGS/POINTS\n6. GOAL SCORERS (without names, just counts)\n7. ANY OTHER NUMERICAL DATA\n\nCOMBINED ARTICLE CONTENT (from ${sourceCount} sources):\n${rawContent}\n\nHEADLINE: ${selectedTopic.headline || \"No headline\"}\n\nReturn ONLY valid JSON:\n{\n  \"score\": \"3-0\" or null,\n  \"homeTeam\": \"Team A\" or null,\n  \"awayTeam\": \"Team B\" or null,\n  \"possession\": { \"home\": 65, \"away\": 35 } or null,\n  \"shots\": { \"home\": 15, \"away\": 8 } or null,\n  \"transferFee\": \"80M\" or null,\n  \"leaguePosition\": 1 or null,\n  \"points\": 45 or null,\n  \"goalCount\": 3 or null,\n  \"keyStatistic\": \"most important number/stat found\",\n  \"dataRichness\": 1-10 (how much real data found)\n}`;\n\n// Build the Gemini request body\nconst requestBody = {\n  contents: [{\n    parts: [{\n      text: promptText\n    }]\n  }]\n};\n\nreturn [{\n  json: {\n    geminiRequestBody: requestBody,\n    selectedTopic: selectedTopic,\n    sourceUrls: mergedData.sourceUrls || [],\n    sourceCount: sourceCount,\n    geminiApiKey: mergedData.geminiApiKey,\n    callbackUrl: mergedData.callbackUrl\n  }\n}];\n"
      }
    },
    {
      "id": "extract-statistics-1769975476415",
      "name": "Extract Statistics",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2750,
        -150
      ],
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.geminiRequestBody) }}",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "id": "parse-statistics-1769975476415",
      "name": "Parse Statistics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2900,
        -150
      ],
      "parameters": {
        "jsCode": "const geminiResponse = $input.first().json;\nconst prevData = $(\"Prepare Stats Request\").first().json;\nconst geminiApiKey = prevData.geminiApiKey;\nconst callbackUrl = prevData.callbackUrl;\nconst selectedTopic = prevData.selectedTopic || {};\nconst sourceUrls = prevData.sourceUrls || [];\nconst sourceCount = prevData.sourceCount || 1;\n\nlet extractedStats = {\n  score: null,\n  homeTeam: null,\n  awayTeam: null,\n  possession: null,\n  shots: null,\n  transferFee: null,\n  leaguePosition: null,\n  points: null,\n  goalCount: null,\n  keyStatistic: null,\n  dataRichness: 1\n};\n\ntry {\n  const candidates = geminiResponse.candidates || [];\n  if (candidates.length > 0) {\n    let text = candidates[0].content?.parts?.[0]?.text || \"\";\n    text = text.replace(/```json\\n?/g, \"\").replace(/```/g, \"\").trim();\n    const parsed = JSON.parse(text);\n    extractedStats = { ...extractedStats, ...parsed };\n  }\n} catch (e) {\n  // Keep defaults\n}\n\n// Build enhanced tagline based on extracted data - with null checks\nlet enhancedTagline = selectedTopic.headline || \"Football Update\";\nconst teams = selectedTopic.teams || [];\n\nif (extractedStats.score && extractedStats.homeTeam && extractedStats.awayTeam) {\n  enhancedTagline = extractedStats.homeTeam + \" \" + extractedStats.score + \" \" + extractedStats.awayTeam;\n} else if (extractedStats.score && teams.length >= 2) {\n  enhancedTagline = (teams[0] || \"\") + \" \" + extractedStats.score + \" \" + (teams[1] || \"\");\n} else if (extractedStats.score && teams.length >= 1) {\n  enhancedTagline = (teams[0] || \"\") + \" \" + extractedStats.score;\n} else if (extractedStats.transferFee) {\n  enhancedTagline = extractedStats.transferFee + \" Transfer Complete\";\n} else if (extractedStats.leaguePosition && extractedStats.points && teams.length > 0) {\n  enhancedTagline = (teams[0] || \"Team\") + \" #\" + extractedStats.leaguePosition + \" (\" + extractedStats.points + \" pts)\";\n}\n\n// Ensure enhancedTagline is a string before trim\nenhancedTagline = String(enhancedTagline || \"Football Update\").trim();\n\nreturn [{\n  json: {\n    selectedTopic: {\n      ...selectedTopic,\n      extractedStats: extractedStats,\n      enhancedTagline: enhancedTagline,\n      hasRealData: extractedStats.dataRichness >= 5\n    },\n    sourceUrls: sourceUrls,\n    sourceCount: sourceCount,\n    sourceLink: selectedTopic.sourceLink || \"\",\n    anonymizedDescriptions: selectedTopic.anonymizedDescriptions || {},\n    geminiApiKey: geminiApiKey,\n    callbackUrl: callbackUrl\n  }\n}];\n"
      }
    },
    {
      "parameters": {
        "jsCode": "const prevData = $input.first().json;\nconst selectedTopic = prevData.selectedTopic || {};\nconst headline = selectedTopic.headline || \"\";\nconst teams = selectedTopic.teams || [];\n\n// Build search query from topic - prioritize team names and key data\nconst searchTerms = [];\n\n// Add teams first (most specific)\nif (teams.length > 0) {\n  searchTerms.push(...teams.slice(0, 2));\n}\n\n// Extract key data-rich words from headline (numbers, proper nouns)\nconst dataWords = headline\n  .replace(/[^a-zA-Z0-9\\s€$£%-]/g, \" \")\n  .split(/\\s+/)\n  .filter(w => {\n    // Keep numbers (scores, fees, etc.)\n    if (/\\d/.test(w)) return true;\n    // Keep likely proper nouns (capitalized, 4+ chars)\n    if (w.length >= 4 && w[0] === w[0].toUpperCase()) return true;\n    return false;\n  })\n  .slice(0, 4);\n\nsearchTerms.push(...dataWords);\n\n// Build the final query\nlet searchQuery = searchTerms.join(\" \");\nif (!searchQuery || searchQuery.length < 5) {\n  // Fallback: use first meaningful words from headline\n  searchQuery = headline.split(/\\s+/).slice(0, 4).join(\" \");\n}\n\n// Append football context\nconst encodedQuery = encodeURIComponent(searchQuery + \" football news\");\nconst searchUrl = \"https://news.google.com/rss/search?q=\" + encodedQuery + \"&hl=en-US&gl=US&ceid=US:en\";\n\n// Primary source comes from the selected topic\nconst primarySource = {\n  url: selectedTopic.sourceLink || selectedTopic.url || \"\",\n  headline: selectedTopic.sourceHeadline || selectedTopic.headline || headline\n};\n\nreturn [{\n  json: {\n    ...prevData,\n    searchQuery: searchQuery,\n    searchUrl: searchUrl,\n    primarySource: primarySource,\n    selectedTopic: selectedTopic\n  }\n}];"
      },
      "name": "Build Search Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1900,
        -200
      ],
      "id": "search-query-builder-001"
    },
    {
      "parameters": {
        "url": "={{ $json.searchUrl }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text"
            }
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            },
            {
              "name": "Accept",
              "value": "application/rss+xml, application/xml, text/xml"
            }
          ]
        }
      },
      "name": "Search Related Sources",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2100,
        -200
      ],
      "id": "search-related-sources-001"
    },
    {
      "parameters": {
        "options": {}
      },
      "name": "Parse Search Results",
      "type": "n8n-nodes-base.xml",
      "typeVersion": 1,
      "position": [
        2300,
        -200
      ],
      "id": "parse-search-results-001"
    },
    {
      "parameters": {
        "jsCode": "const rssData = $input.first().json;\nconst prevData = $(\"Build Search Query\").first().json;\nconst primarySource = prevData.primarySource || {};\n\n// Debug: log what we received\nconsole.log(\"RSS data keys:\", Object.keys(rssData || {}));\nconsole.log(\"Has rss:\", !!rssData?.rss);\nconsole.log(\"Has channel:\", !!rssData?.rss?.channel);\n\n// Extract articles from RSS\nconst items = rssData?.rss?.channel?.item || [];\nconsole.log(\"Found items count:\", items.length);\n\n// Collect up to 5 sources (including primary)\nconst sources = [];\n\n// Add primary source first\nif (primarySource.url) {\n  sources.push({\n    url: primarySource.url,\n    headline: primarySource.headline,\n    isPrimary: true\n  });\n}\n\n// Add related sources (skip duplicates)\nconst seenUrls = new Set([primarySource.url?.toLowerCase()]);\n\nfor (const item of items.slice(0, 10)) {\n  if (sources.length >= 5) break;\n  \n  const link = item.link || \"\";\n  const title = item.title || \"\";\n  \n  // Skip if no link\n  if (!link) continue;\n  \n  // Skip if duplicate URL\n  if (seenUrls.has(link.toLowerCase())) continue;\n  \n  seenUrls.add(link.toLowerCase());\n  sources.push({\n    url: link,\n    headline: title,\n    isPrimary: false\n  });\n}\n\nconsole.log(\"Final source count:\", sources.length);\n\nreturn [{\n  json: {\n    ...prevData,\n    sources: sources,\n    sourceCount: sources.length,\n    debugItemCount: items.length\n  }\n}];\n"
      },
      "name": "Collect Sources",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        -200
      ],
      "id": "collect-sources-001"
    },
    {
      "parameters": {
        "jsCode": "const prevData = $input.first().json;\nconst sources = prevData.sources || [];\n\n// Create HTTP requests for each source\nconst requests = sources.map((source, index) => ({\n  json: {\n    sourceIndex: index,\n    sourceUrl: source.url,\n    sourceHeadline: source.headline,\n    isPrimary: source.isPrimary,\n    allSources: sources,\n    selectedTopic: prevData.selectedTopic,\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}));\n\nreturn requests;"
      },
      "name": "Split Sources",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2700,
        -200
      ],
      "id": "split-sources-001"
    },
    {
      "parameters": {
        "url": "={{ $json.sourceUrl }}",
        "options": {
          "response": {
            "response": {
              "fullResponse": false,
              "responseFormat": "text"
            }
          },
          "timeout": 10000
        }
      },
      "name": "Fetch Source Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2900,
        -200
      ],
      "id": "fetch-source-content-001",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Get HTML content from HTTP Request and metadata from Split Sources\nconst httpItems = $input.all();  // HTTP Response items (just { data: \"html\" })\nconst splitItems = $(\"Split Sources\").all();  // Original items with metadata\n\nconst results = [];\n\nfor (let i = 0; i < httpItems.length; i++) {\n  const htmlContent = httpItems[i]?.json?.data || \"\";\n  const metadata = splitItems[i]?.json || {};\n  \n  const sourceIndex = metadata.sourceIndex ?? i;\n  const sourceUrl = metadata.sourceUrl || \"\";\n  const sourceHeadline = metadata.sourceHeadline || \"\";\n  const isPrimary = metadata.isPrimary || false;\n  const allSources = metadata.allSources || [];\n  const selectedTopic = metadata.selectedTopic;\n  const geminiApiKey = metadata.geminiApiKey;\n  const callbackUrl = metadata.callbackUrl;\n\n  // Extract text from HTML (basic extraction)\n  let text = \"\";\n  if (typeof htmlContent === \"string\") {\n    text = htmlContent\n      .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \"\")\n      .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \"\")\n      .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, \"\")\n      .replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, \"\")\n      .replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, \"\")\n      .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, \"\")\n      .replace(/<[^>]+>/g, \" \")\n      .replace(/&nbsp;/g, \" \")\n      .replace(/&amp;/g, \"&\")\n      .replace(/&lt;/g, \"<\")\n      .replace(/&gt;/g, \">\")\n      .replace(/\\s+/g, \" \")\n      .trim()\n      .slice(0, 8000);\n  }\n\n  results.push({\n    json: {\n      sourceIndex,\n      sourceUrl,\n      sourceHeadline,\n      isPrimary,\n      content: text,\n      allSources,\n      selectedTopic,\n      geminiApiKey,\n      callbackUrl\n    }\n  });\n}\n\nreturn results;\n"
      },
      "name": "Parse Source Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3100,
        -200
      ],
      "id": "parse-source-content-001"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "name": "Aggregate Sources",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        3300,
        -200
      ],
      "id": "aggregate-sources-001"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.first().json.data || [];\nconst firstItem = items[0] || {};\nconst allSources = firstItem.allSources || [];\nconst selectedTopic = firstItem.selectedTopic || {};\n\n// Build combined content\nconst articlesText = items\n  .sort((a, b) => (b.isPrimary ? 1 : 0) - (a.isPrimary ? 1 : 0))\n  .map((item, idx) => {\n    const label = item.isPrimary ? '[PRIMARY SOURCE]' : '[SOURCE ' + (idx + 1) + ']';\n    return label + '\\nHeadline: ' + item.sourceHeadline + '\\nContent: ' + (item.content || 'No content available').slice(0, 3000);\n  })\n  .join('\\n\\n---\\n\\n');\n\n// Build source URLs for citations\nconst sourceUrls = allSources.map((s, i) => ({\n  index: i + 1,\n  url: s.url,\n  headline: s.headline\n}));\n\nreturn [{\n  json: {\n    articlesText,\n    sourceUrls,\n    sourceCount: items.length,\n    selectedTopic,\n    geminiApiKey: firstItem.geminiApiKey,\n    callbackUrl: firstItem.callbackUrl\n  }\n}];"
      },
      "name": "Merge All Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3500,
        -200
      ],
      "id": "merge-all-content-001"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-goog-api-key",
              "value": "={{ $json.geminiApiKey }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are an objective football journalist synthesizing multiple sources into a comprehensive summary.\\n\\nARTICLES:\\n{{ $json.articlesText }}\\n\\nAnalyze ALL sources and extract:\\n\\nReturn ONLY a JSON object with:\\n{\\n  \\\"summary\\\": \\\"2-3 paragraph objective summary synthesizing all sources (NO player names, focus on facts and numbers)\\\",\\n  \\\"stats\\\": {\\n    \\\"score\\\": \\\"final score if match (e.g. 2-1) or null\\\",\\n    \\\"possession\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"shots\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"shotsOnTarget\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"xG\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"corners\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"fouls\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"yellowCards\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"redCards\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"transferFee\\\": \\\"transfer amount if applicable or null\\\",\\n    \\\"leaguePosition\\\": number or null,\\n    \\\"points\\\": number or null,\\n    \\\"goalDifference\\\": number or null,\\n    \\\"winStreak\\\": number or null,\\n    \\\"cleanSheets\\\": number or null,\\n    \\\"otherStats\\\": [\\\"any other significant numbers found\\\"]\\n  },\\n  \\\"teams\\\": [\\\"team names mentioned\\\"],\\n  \\\"competition\\\": \\\"league/tournament name\\\",\\n  \\\"keyFacts\\\": [\\\"3-5 bullet point facts\\\"],\\n  \\\"dataConfidence\\\": \\\"high/medium/low - based on source agreement\\\"\\n}\\n\\nBe thorough - extract EVERY statistic mentioned across ALL sources. Prioritize numbers and objective facts.\\\"\\n    }]\\n  }]\\n}\"\n    }",
        "options": {},
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth"
      },
      "name": "Comprehensive Summary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3700,
        -200
      ],
      "id": "comprehensive-summary-001",
      "credentials": {
        "httpHeaderAuth": {
          "id": "K9oPxIngg8rE26T6",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Merge All Content\").first().json;\n\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const summary = JSON.parse(cleaned);\n  return [{\n    json: {\n      comprehensiveSummary: summary.summary,\n      extractedStats: summary.stats,\n      teams: summary.teams,\n      competition: summary.competition,\n      keyFacts: summary.keyFacts,\n      dataConfidence: summary.dataConfidence,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      selectedTopic: prevData.selectedTopic,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      comprehensiveSummary: prevData.selectedTopic?.headline || \"Football news update\",\n      extractedStats: {},\n      teams: prevData.selectedTopic?.teams || [],\n      competition: \"\",\n      keyFacts: [],\n      dataConfidence: \"low\",\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      selectedTopic: prevData.selectedTopic,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
      },
      "name": "Parse Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3900,
        -200
      ],
      "id": "parse-summary-001"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"comprehensive-summary\",\n  \"stepIndex\": 5,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"summary\": {{ JSON.stringify($json.comprehensiveSummary || \"\") }},\n    \"stats\": {{ JSON.stringify($json.extractedStats || {}) }},\n    \"teams\": {{ JSON.stringify($json.teams || []) }},\n    \"competition\": {{ JSON.stringify($json.competition || \"\") }},\n    \"keyFacts\": {{ JSON.stringify($json.keyFacts || []) }},\n    \"sourceCount\": {{ $json.sourceCount || 0 }},\n    \"dataConfidence\": {{ JSON.stringify($json.dataConfidence || \"low\") }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
        "options": {}
      },
      "name": "Callback Summary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        4000,
        -300
      ],
      "id": "callback-summary-001",
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"eventSummary-generated\",\n  \"stepIndex\": 7,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"eventSummary\": {{ JSON.stringify($json.eventSummary || \"\") }},\n    \"imagePrompt\": {{ JSON.stringify($json.imagePrompt || \"\").substring(0, 500) }},\n    \"selectedStats\": {{ JSON.stringify($json.selectedStats || []) }},\n    \"sceneType\": {{ JSON.stringify($json.sceneType || \"\") }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
        "options": {}
      },
      "name": "Callback Event Summary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2950,
        250
      ],
      "id": "callback-tagline-001",
      "continueOnFail": true
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Fetch RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch RSS": {
      "main": [
        [
          {
            "node": "Parse XML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse XML": {
      "main": [
        [
          {
            "node": "Extract Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Articles": {
      "main": [
        [
          {
            "node": "Topic Analyst",
            "type": "main",
            "index": 0
          },
          {
            "node": "Callback Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Post": {
      "main": [
        [
          {
            "node": "Parse Post",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Image": {
      "main": [
        [
          {
            "node": "Parse Image Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Final Output": {
      "main": [
        [
          {
            "node": "Callback Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Callback Final": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Imagen API": {
      "main": [
        [
          {
            "node": "Parse Imagen Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Imagen Response": {
      "main": [
        [
          {
            "node": "Brand Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Topic Analyst": {
      "main": [
        [
          {
            "node": "Parse Topic Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Topic Analysis": {
      "main": [
        [
          {
            "node": "Build Compliance Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compliance Checker": {
      "main": [
        [
          {
            "node": "Parse Compliance Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Compliance Check": {
      "main": [
        [
          {
            "node": "Aggregate Compliant Topics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Compliant Topics": {
      "main": [
        [
          {
            "node": "Build Search Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Post": {
      "main": [
        [
          {
            "node": "Build Image Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Image Prompt": {
      "main": [
        [
          {
            "node": "Generate Event Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hashtag Researcher": {
      "main": [
        [
          {
            "node": "Parse Hashtags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Hashtags": {
      "main": [
        [
          {
            "node": "Prepare Post Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Post Request": {
      "main": [
        [
          {
            "node": "Generate Post",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Event Summary": {
      "main": [
        [
          {
            "node": "Parse Event Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Event Summary": {
      "main": [
        [
          {
            "node": "Call Imagen API",
            "type": "main",
            "index": 0
          },
          {
            "node": "Callback Event Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Brand Image": {
      "main": [
        [
          {
            "node": "Parse Brand Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Brand Response": {
      "main": [
        [
          {
            "node": "Build Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Compliance Request": {
      "main": [
        [
          {
            "node": "Compliance Checker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Image Request": {
      "main": [
        [
          {
            "node": "Generate Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Stats Request": {
      "main": [
        [
          {
            "node": "Extract Statistics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Statistics": {
      "main": [
        [
          {
            "node": "Parse Statistics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Statistics": {
      "main": [
        [
          {
            "node": "Hashtag Researcher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Search Query": {
      "main": [
        [
          {
            "node": "Search Related Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Related Sources": {
      "main": [
        [
          {
            "node": "Parse Search Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Search Results": {
      "main": [
        [
          {
            "node": "Collect Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Sources": {
      "main": [
        [
          {
            "node": "Split Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Sources": {
      "main": [
        [
          {
            "node": "Fetch Source Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Source Content": {
      "main": [
        [
          {
            "node": "Parse Source Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Source Content": {
      "main": [
        [
          {
            "node": "Aggregate Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Sources": {
      "main": [
        [
          {
            "node": "Merge All Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Content": {
      "main": [
        [
          {
            "node": "Prepare Stats Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Comprehensive Summary": {
      "main": [
        [
          {
            "node": "Parse Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Summary": {
      "main": [
        [
          {
            "node": "Hashtag Researcher",
            "type": "main",
            "index": 0
          },
          {
            "node": "Callback Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "node:Schedule Trigger": {
      "recurrenceRules": []
    }
  },
  "meta": null,
  "pinData": {},
  "versionId": "220bc091-4602-4a82-9f94-38bf6a4a70b0",
  "activeVersionId": "220bc091-4602-4a82-9f94-38bf6a4a70b0",
  "versionCounter": 412,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-01-25T09:36:24.236Z",
      "createdAt": "2026-01-25T09:36:24.236Z",
      "role": "workflow:owner",
      "workflowId": "oV6WGX5uBeTZ9tRa",
      "projectId": "tYcTNrTV20x5m3NS",
      "project": {
        "updatedAt": "2026-01-21T18:01:18.310Z",
        "createdAt": "2026-01-21T18:01:12.176Z",
        "id": "tYcTNrTV20x5m3NS",
        "name": "Bilko Bibitkov <bilkobibitkov2000@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "80f5768f-36e3-4197-9886-2f8e29df41d7",
        "projectRelations": [
          {
            "updatedAt": "2026-01-21T18:01:12.176Z",
            "createdAt": "2026-01-21T18:01:12.176Z",
            "userId": "80f5768f-36e3-4197-9886-2f8e29df41d7",
            "projectId": "tYcTNrTV20x5m3NS",
            "user": {
              "updatedAt": "2026-02-01T08:12:40.000Z",
              "createdAt": "2026-01-21T18:01:09.996Z",
              "id": "80f5768f-36e3-4197-9886-2f8e29df41d7",
              "email": "bilkobibitkov2000@gmail.com",
              "firstName": "Bilko",
              "lastName": "Bibitkov",
              "personalizationAnswers": null,
              "settings": {
                "userActivated": true,
                "userClaimedAiCredits": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "d144QoAsV5hIbzvQ",
                "userActivatedAt": 1769150504302,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1769766178056
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-01",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-02T04:57:59.604Z",
    "createdAt": "2026-02-02T04:57:59.604Z",
    "versionId": "220bc091-4602-4a82-9f94-38bf6a4a70b0",
    "workflowId": "oV6WGX5uBeTZ9tRa",
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "european-football-daily",
          "responseMode": "onReceived",
          "options": {}
        },
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 1,
        "position": [
          0,
          208
        ],
        "id": "0025e044-d2ba-4e9f-8e73-98ca642c1087",
        "webhookId": "191adfc0-b71a-41c2-8a26-25ca9ec0b6c1"
      },
      {
        "parameters": {
          "url": "https://news.google.com/rss/search?q=european+football+champions+league+OR+premier+league+OR+la+liga+OR+bundesliga+OR+serie+a&hl=en-US&gl=US&ceid=US:en",
          "options": {}
        },
        "name": "Fetch RSS",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          512,
          112
        ],
        "id": "a0c4d441-f13a-4003-8f49-1a710d29c12e"
      },
      {
        "parameters": {
          "options": {}
        },
        "name": "Parse XML",
        "type": "n8n-nodes-base.xml",
        "typeVersion": 1,
        "position": [
          752,
          112
        ],
        "id": "9466c9e8-2426-4e44-8a8e-ef37a1138c38"
      },
      {
        "parameters": {
          "jsCode": "const rss = $input.first().json;\nconst webhookData = $('Webhook').first().json.body || {};\nconst recentTopics = webhookData.recentTopics || [];\n\n// Build normalized headline set for exact matching\nconst recentHeadlinesNormalized = new Set(\n  recentTopics.map(t => t.headline.toLowerCase().trim().replace(/[^a-z0-9\\s]/g, ''))\n);\n\nconst items = rss?.rss?.channel?.item || [];\n\nconst articles = items.slice(0, 20).map(item => ({\n  title: item.title || '',\n  sourceHeadline: item.title || '', // Preserve original for callback\n  link: item.link || '',\n  source: 'Google News',\n  pubDate: item.pubDate || ''\n})).filter(a => {\n  const normalizedTitle = a.title.toLowerCase().trim().replace(/[^a-z0-9\\s]/g, '');\n  \n  // PRIMARY: Normalized exact headline match\n  if (recentHeadlinesNormalized.has(normalizedTitle)) {\n    return false;\n  }\n  \n  // SECONDARY: Word overlap check (>50% = likely duplicate)\n  const words = new Set(normalizedTitle.split(/\\s+/).filter(w => w.length > 3));\n  if (words.size >= 3) {\n    for (const recent of recentTopics) {\n      const recentNorm = recent.headline.toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n      const recentWords = new Set(recentNorm.split(/\\s+/).filter(w => w.length > 3));\n      if (recentWords.size >= 3) {\n        const overlap = [...words].filter(w => recentWords.has(w)).length;\n        const similarity = overlap / Math.min(words.size, recentWords.size);\n        if (similarity > 0.5) {\n          return false;\n        }\n      }\n    }\n  }\n  \n  return true;\n}).slice(0, 10);\n\n// Fallback if all filtered out\nif (articles.length === 0 && items.length > 0) {\n  const first = items[0];\n  return [{\n    json: {\n      title: first.title || 'European Football Update',\n      sourceHeadline: first.title || 'European Football Update',\n      link: first.link || '',\n      source: 'Google News',\n      pubDate: first.pubDate || '',\n      forcedFallback: true,\n      recentTopicsCount: recentTopics.length\n    }\n  }];\n}\n\nreturn articles.map(a => ({ json: { ...a, recentTopicsCount: recentTopics.length } }));"
        },
        "name": "Extract Articles",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1008,
          112
        ],
        "id": "2a98ef6a-8bc2-4312-9ae1-9c72f99e4b84"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"extract-articles\",\n  \"stepIndex\": 1,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"articles\": {{ JSON.stringify($input.all().map(i => i.json)) }},\n    \"count\": {{ $input.all().length }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
          "options": {}
        },
        "name": "Callback Articles",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1104,
          256
        ],
        "id": "c6ed77f1-fb89-4efe-875f-2c7668fa7140"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $input.first().json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json.geminiRequestBody) }}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "name": "Generate Post",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2816,
          -32
        ],
        "id": "7c494835-fa77-48c9-ae73-269be50bb6af",
        "retryOnFail": true,
        "maxTries": 5,
        "waitBetweenTries": 5000,
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Hashtags\").first().json;\n\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Remove markdown code fences - handle both ```json and ``` at start/end\nlet cleaned = text.trim();\nif (cleaned.startsWith('```')) {\n  // Remove opening fence (```json or ```)\n  cleaned = cleaned.replace(/^```[a-zA-Z]*\\s*/, '');\n}\nif (cleaned.endsWith('```')) {\n  // Remove closing fence\n  cleaned = cleaned.replace(/\\s*```$/, '');\n}\ncleaned = cleaned.trim();\n\ntry {\n  const post = JSON.parse(cleaned);\n  let postContent = post.postContent || \"\";\n  \n  // Get source URLs - fallback to sourceLink if sourceUrls is empty\n  let sourceUrls = prevData.sourceUrls || [];\n  const sourceLink = prevData.sourceLink || prevData.selectedTopic?.sourceLink;\n  \n  // If sourceUrls is empty but we have sourceLink, use it\n  if (sourceUrls.length === 0 && sourceLink) {\n    sourceUrls = [{ url: sourceLink, title: \"Source\" }];\n  }\n  \n  // Add source citations at the end (before hashtags)\n  if (sourceUrls.length > 0) {\n    // Find where hashtags start (# followed by word)\n    const hashtagMatch = postContent.match(/#[A-Za-z]/);\n    let beforeHashtags = postContent;\n    let hashtags = \"\";\n    \n    if (hashtagMatch) {\n      const hashtagIndex = postContent.indexOf(hashtagMatch[0]);\n      beforeHashtags = postContent.slice(0, hashtagIndex).trim();\n      hashtags = postContent.slice(hashtagIndex).trim();\n    }\n    \n    // Build citation line with numbered hyperlinks\n    const citations = sourceUrls.map((s, i) => \n      \"[\" + (i + 1) + \"](\" + s.url + \")\"\n    ).join(\" \");\n    \n    // Reconstruct post with sources\n    postContent = beforeHashtags + \"\\n\\nSources: \" + citations + \"\\n\\n\" + hashtags;\n  }\n  \n  return [{\n    json: {\n      postContent: postContent,\n      sentiment: post.sentiment || \"neutral\",\n      statsHighlighted: post.statsHighlighted || [],\n      safeImagePrompt: prevData.selectedTopic?.safeImagePrompt,\n      anonymizedDescriptions: prevData.selectedTopic?.anonymizedDescriptions || prevData.anonymizedDescriptions || {},\n      selectedTopic: prevData.selectedTopic,\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      extractedStats: prevData.extractedStats || {},\n      teams: prevData.teams,\n      competition: prevData.competition,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  // Get source URLs - fallback to sourceLink if sourceUrls is empty\n  let sourceUrls = prevData.sourceUrls || [];\n  const sourceLink = prevData.sourceLink || prevData.selectedTopic?.sourceLink;\n  \n  // If sourceUrls is empty but we have sourceLink, use it\n  if (sourceUrls.length === 0 && sourceLink) {\n    sourceUrls = [{ url: sourceLink, title: \"Source\" }];\n  }\n  \n  const citations = sourceUrls.map((s, i) => \"[\" + (i + 1) + \"](\" + s.url + \")\").join(\" \");\n  \n  return [{\n    json: {\n      postContent: \"Football news update! Exciting developments in European football today.\\n\\nSources: \" + citations,\n      sentiment: \"neutral\",\n      statsHighlighted: [],\n      safeImagePrompt: prevData.selectedTopic?.safeImagePrompt || \"Exciting football stadium scene\",\n      anonymizedDescriptions: prevData.selectedTopic?.anonymizedDescriptions || {},\n      selectedTopic: prevData.selectedTopic,\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      extractedStats: prevData.extractedStats || {},\n      teams: prevData.teams,\n      competition: prevData.competition,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message,\n      rawText: text.substring(0, 200)\n    }\n  }];\n}\n"
        },
        "name": "Parse Post",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2000,
          112
        ],
        "id": "5ffc1c44-ad8f-4df3-bb2c-2ac5ec931d9f"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $input.first().json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "fb8ce752-bb66-4d73-abb2-24fad043a177",
        "name": "Generate Image",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2256,
          112
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Post\").first().json;\n\n// Get Gemini response\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const imageData = JSON.parse(cleaned);\n  return [{\n    json: {\n      imagePrompt: imageData.imagePrompt,\n      style: imageData.style || \"photorealistic\",\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      imagePrompt: \"Exciting football celebration scene in a modern stadium\",\n      style: \"photorealistic\",\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      sourceLink: prevData.sourceLink || \"\",\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Image Prompt",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2512,
          112
        ],
        "id": "654ab797-28bc-4e88-a66c-74887fbedae5"
      },
      {
        "parameters": {
          "jsCode": "const brandingResult = $input.first().json;\n\nconst postContent = brandingResult.postContent || \"Football news update!\";\nconst imagePrompt = brandingResult.imagePrompt || \"European football celebration\";\nconst sourceLink = brandingResult.sourceLink || \"\";\nconst extractedStats = brandingResult.extractedStats || {};\nconst selectedTopic = brandingResult.selectedTopic || {};\nconst sourceUrls = brandingResult.sourceUrls || [];\nconst comprehensiveSummary = brandingResult.comprehensiveSummary || \"\";\nconst keyFacts = brandingResult.keyFacts || [];\nconst infographicElements = brandingResult.infographicElements || [];\n\nlet imageDataUri = brandingResult.imageDataUri || null;\nif (brandingResult.success && brandingResult.brandedImageBase64) {\n  imageDataUri = \"data:image/png;base64,\" + brandingResult.brandedImageBase64;\n}\n\n// Build source citations for transparency post\nconst citations = sourceUrls.map((s, i) => \"[\" + (i + 1) + \"] \" + s.url).join(\"\\n\");\n\nlet transparencyPost = \"I've developed this AI-driven system to efficiently curate European football news, serving as a professional 'proof of work' for AI integration. Grounded in transparency and the human-in-the-loop principle, this project demonstrates how AI can enhance specialized content. Follow for updates, or visit my bio to learn how to build similar systems.\\n\\nBilko Bibitkov Human-Centric AI Curation\\n\\n\" + brandingResult.sourceCount + \" sources analyzed for this report.\";\n\nif (citations) {\n  transparencyPost += \"\\n\\nSources:\\n\" + citations;\n}\n\nconst output = {\n  success: true,\n  selectedTopic: {\n    headline: selectedTopic.headline || \"\",\n    sourceHeadline: selectedTopic.sourceHeadline || selectedTopic.headline || \"\",\n    sourceHeadlineHash: selectedTopic.sourceHeadlineHash || \"\",\n    teams: selectedTopic.teams || [],\n    event: selectedTopic.event || \"\",\n    dataRichness: extractedStats.dataConfidence || selectedTopic.dataRichness || 0,\n    brandValue: selectedTopic.brandValue || 0,\n    extractedStats: extractedStats,\n    eventSummary: brandingResult.eventSummary || \"\"\n  },\n  data: {\n    postContent: postContent,\n    comprehensiveSummary: comprehensiveSummary,\n    keyFacts: keyFacts,\n    imagePrompt: imagePrompt,\n    imageUrl: imageDataUri,\n    eventSummary: brandingResult.eventSummary || \"\",\n    infographicElements: infographicElements,\n    transparencyPost: transparencyPost,\n    sourceLink: sourceLink,\n    sourceUrls: sourceUrls,\n    sourceCount: brandingResult.sourceCount || 1,\n    contentFiltered: !imageDataUri\n  }\n};\n\nreturn [{ json: output }];"
        },
        "name": "Build Final Output",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3600,
          112
        ],
        "id": "71b64e2c-1852-4ef6-a21d-732907892df3"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"final-output\",\n  \"stepIndex\": 3,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {{ JSON.stringify($input.first().json) }},\n  \"executionId\": \"{{ $execution.id }}\"\n}",
          "options": {}
        },
        "name": "Callback Final",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3008,
          112
        ],
        "id": "5a99a7c6-1f47-47eb-a13d-888ae0334bcf"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ $('Build Final Output').first().json }}",
          "options": {}
        },
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1,
        "position": [
          3264,
          208
        ],
        "id": "4ea89a64-7267-4476-aac6-d67c10a7da98"
      },
      {
        "parameters": {
          "content": "PRODUCTION"
        },
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          416,
          496
        ],
        "id": "303bff0e-4feb-4c29-903e-cd2782ab38ba",
        "name": "Sticky Note"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0; +https://bilkobibitkov.replit.app)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"{{ $json.imagePrompt }}. Include bold stylized text overlay on the image saying: {{ $json.eventSummary }}\"\n    }]\n  }],\n  \"generation_config\": {\n    \"response_modalities\": [\"IMAGE\"],\n    \"image_config\": {\n      \"aspect_ratio\": \"1:1\"\n    }\n  }\n}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "74affa50-0102-49a6-8190-3e24f1ec0a2e",
        "name": "Call Imagen API",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3104,
          112
        ],
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Event Summary\").first().json;\n\nconst parts = input?.candidates?.[0]?.content?.parts || [];\nconst imagePart = parts.find(p => p.inlineData?.mimeType?.startsWith(\"image/\"));\n\nif (imagePart && imagePart.inlineData?.data) {\n  const mimeType = imagePart.inlineData.mimeType;\n  const base64Data = imagePart.inlineData.data;\n  const imageDataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n\n  return [{\n    json: {\n      imageDataUri: imageDataUri,\n      imagePrompt: prevData.imagePrompt,\n      eventSummary: prevData.eventSummary,\n      infographicElements: prevData.infographicElements,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: prevData.sourceLink,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} else {\n  return [{\n    json: {\n      imageDataUri: null,\n      imagePrompt: prevData.imagePrompt,\n      eventSummary: prevData.eventSummary,\n      infographicElements: prevData.infographicElements,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: prevData.sourceLink,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      imagenError: \"No image data in response\"\n    }\n  }];\n}"
        },
        "id": "ec694419-9c45-4f5d-b2a9-56f136492315",
        "name": "Parse Imagen Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3360,
          112
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Analyze this football news headline and extract key information for social media.\\n\\nHEADLINE: {{ $json.title }}\\n\\nReturn ONLY a JSON object with:\\n- headline: the original headline\\n- teams: array of team names mentioned (prioritize big clubs: Real Madrid, Barcelona, Man City, Liverpool, Bayern, PSG, Juventus, etc.)\\n- event: brief description (match result, transfer, injury, etc.)\\n- hasScore: boolean - true if headline contains a match score like 3-0, 2-1\\n- hasNumbers: boolean - true if contains significant numbers (transfer fees, goals, points, positions)\\n- dataRichness: score 1-10 (10=has scores/stats/numbers, 5=has team names, 1=vague/generic)\\n- brandValue: score 1-10 (10=mentions top clubs/leagues/tournaments, 1=unknown teams)\\n- imageability: score 1-10 how easy to create a generic image\\n- imageSuggestion: a generic image concept avoiding real people names\\n\\nPrioritize headlines with: actual scores, transfer fees, league standings, big club names.\\nExample: { \\\"headline\\\": \\\"Barcelona 3-0 Real Madrid\\\", \\\"teams\\\": [\\\"Barcelona\\\", \\\"Real Madrid\\\"], \\\"event\\\": \\\"El Clasico victory\\\", \\\"hasScore\\\": true, \\\"hasNumbers\\\": true, \\\"dataRichness\\\": 10, \\\"brandValue\\\": 10, \\\"imageability\\\": 9, \\\"imageSuggestion\\\": \\\"celebrating football team in red and blue\\\" }\"\n    }]\n  }]\n}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 1,
                "batchInterval": 2000
              }
            }
          },
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "3bcffc23-1424-49a1-afd7-7f0514ed2ef7",
        "name": "Topic Analyst",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1312,
          -32
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst geminiApiKey = $(\"Webhook\").first().json.body.geminiApiKey;\nconst callbackUrl = $(\"Webhook\").first().json.body.callbackUrl;\n\n// Get the source article data from Extract Articles using item index\nconst articleItems = $(\"Extract Articles\").all();\nconst currentIndex = $runIndex;\nconst articleData = articleItems[currentIndex]?.json || {};\nconst sourceLink = articleData.link || \"\";\nconst sourceHeadline = articleData.sourceHeadline || articleData.title || \"\";\nconst sourceHeadlineHash = articleData.titleHash || \"\";\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const analysis = JSON.parse(cleaned);\n  return [{\n    json: {\n      ...analysis,\n      sourceLink: sourceLink,\n      sourceHeadline: sourceHeadline,\n      sourceHeadlineHash: sourceHeadlineHash,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      headline: \"Football news update\",\n      people: [],\n      teams: [],\n      event: \"general news\",\n      imageability: 5,\n      imageSuggestion: \"generic football stadium scene\",\n      sourceLink: sourceLink,\n      sourceHeadline: sourceHeadline,\n      sourceHeadlineHash: sourceHeadlineHash,\n      parseError: e.message,\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}"
        },
        "id": "4a292d0b-d120-4074-87fc-6667de4e4de6",
        "name": "Parse Topic Analysis",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1616,
          -32
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 1,
                "batchInterval": 2000
              }
            }
          },
          "contentType": "json",
          "jsonBody": "={{ JSON.stringify($json.requestBody) }}",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "9c51724e-f9eb-4bea-a72c-3dbf6c163d0a",
        "name": "Compliance Checker",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          1920,
          -32
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Topic Analysis\").first().json;\n\n// Get the text response from Gemini\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\n\n// Strip markdown fences if present\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const compliance = JSON.parse(cleaned);\n  return [{\n    json: {\n      headline: prevData.headline,\n      people: prevData.people,\n      teams: prevData.teams,\n      event: prevData.event,\n      imageability: prevData.imageability,\n      imageSuggestion: prevData.imageSuggestion,\n      sourceLink: prevData.sourceLink,\n      sourceHeadline: prevData.sourceHeadline,\n      sourceHeadlineHash: prevData.sourceHeadlineHash,\n      compliant: compliance.compliant !== false,\n      complianceReason: compliance.reason,\n      anonymizedDescriptions: compliance.anonymizedDescriptions || {},\n      safeImagePrompt: compliance.safeImagePrompt,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ...prevData,\n      compliant: true,\n      complianceReason: \"Parse error, using fallback: \" + e.message,\n      anonymizedDescriptions: {},\n      safeImagePrompt: \"Generic football stadium celebration scene with fans cheering\"\n    }\n  }];\n}"
        },
        "id": "e2dd7a80-e193-4290-a91b-542eb7f02b52",
        "name": "Parse Compliance Check",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2208,
          -32
        ]
      },
      {
        "parameters": {
          "jsCode": "// Collect all items (each article's compliance check result)\nconst items = $input.all();\nconst geminiApiKey = items[0]?.json?.geminiApiKey;\nconst callbackUrl = items[0]?.json?.callbackUrl;\n\n// Filter to only compliant topics and sort by data-richness + brand value\nconst compliantTopics = items\n  .map(item => item.json)\n  .filter(topic => topic.compliant === true)\n  .sort((a, b) => {\n    // Combined score prioritizing data-rich, high-brand topics\n    const scoreA = (a.dataRichness || 0) * 2 + (a.brandValue || 0) * 1.5 + (a.imageability || 0);\n    const scoreB = (b.dataRichness || 0) * 2 + (b.brandValue || 0) * 1.5 + (b.imageability || 0);\n    return scoreB - scoreA;\n  });\n\n// If no compliant topics, create a safe fallback\nif (compliantTopics.length === 0) {\n  return [{\n    json: {\n      selectedTopic: {\n        headline: 'European Football Weekly Update',\n        teams: [],\n        event: 'weekly roundup',\n        safeImagePrompt: 'Exciting football match scene in a packed stadium with cheering fans',\n        anonymizedDescriptions: {},\n        fallback: true\n      },\n      allTopics: items.map(i => i.json),\n      geminiApiKey,\n      callbackUrl\n    }\n  }];\n}\n\n// Select the best topic (highest combined score)\nreturn [{\n  json: {\n    selectedTopic: compliantTopics[0],\n    alternativeTopics: compliantTopics.slice(1, 3),\n    allTopics: items.map(i => i.json),\n    geminiApiKey,\n    callbackUrl\n  }\n}];"
        },
        "id": "2426cf99-5a5b-4963-9ffc-81c4ec3cee01",
        "name": "Aggregate Compliant Topics",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2512,
          -32
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $json.geminiApiKey }}"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Find the 3 most relevant, high-reach hashtags for this European football topic.\\n\\nTOPIC: {{ $json.selectedTopic.headline }}\\nEVENT: {{ $json.selectedTopic.event }}\\nTEAMS: {{ ($json.selectedTopic.teams || []).join(', ') }}\\nKEY DATA: {{ $json.selectedTopic?.extractedStats?.keyStatistic || 'general football news' }}\\n\\nRules:\\n- Return EXACTLY 3 hashtags\\n- Must be real, widely-used hashtags on social media\\n- Must be directly relevant to this specific topic/teams/event\\n- Include the # symbol\\n- Prefer hashtags with high engagement (millions of posts)\\n\\nReturn ONLY a JSON object: {\\\"hashtags\\\": [\\\"#tag1\\\", \\\"#tag2\\\", \\\"#tag3\\\"]}\"\n    }]\n  }]\n}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "id": "hashtag-researcher-1769380010487",
        "name": "Hashtag Researcher",
        "type": "n8n-nodes-base.httpRequest",
        "position": [
          2816,
          -32
        ],
        "typeVersion": 4.2,
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Get Gemini response from HTTP Request\nconst geminiResponse = $input.first().json;\n\n// Get original data from Aggregate Compliant Topics or Parse Statistics (whichever is available)\nlet originalData;\ntry {\n  originalData = $(\"Parse Statistics\").first().json;\n} catch (e) {\n  try {\n    originalData = $(\"Aggregate Compliant Topics\").first().json;\n  } catch (e2) {\n    originalData = {};\n  }\n}\n\nconst geminiApiKey = originalData.geminiApiKey;\nconst callbackUrl = originalData.callbackUrl;\nconst selectedTopic = originalData.selectedTopic || {};\nconst extractedStats = selectedTopic.extractedStats || originalData.extractedStats || {};\nconst teams = selectedTopic.teams || [];\nconst competition = selectedTopic.competition || \"\";\nconst sourceUrls = originalData.sourceUrls || [];\nconst sourceCount = originalData.sourceCount || 1;\n\n// Parse hashtags from Gemini response\nlet hashtags = [\"#football\", \"#soccer\", \"#UEFA\"]; // fallback\ntry {\n  const candidates = geminiResponse.candidates || [];\n  if (candidates.length > 0) {\n    let text = candidates[0].content?.parts?.[0]?.text || \"\";\n    text = text.replace(/```json\\n?/g, \"\").replace(/```/g, \"\").trim();\n    const parsed = JSON.parse(text);\n    if (parsed.hashtags && Array.isArray(parsed.hashtags)) {\n      hashtags = parsed.hashtags.slice(0, 3);\n    }\n  }\n} catch (e) {\n  // Keep fallback\n}\n\nreturn [{\n  json: {\n    selectedTopic: selectedTopic,\n    extractedStats: extractedStats,\n    teams: teams,\n    competition: competition,\n    sourceUrls: sourceUrls,\n    sourceCount: sourceCount,\n    sourceLink: selectedTopic?.sourceLink || \"\",\n    anonymizedDescriptions: selectedTopic?.anonymizedDescriptions || {},\n    hashtags: hashtags,\n    hashtagString: hashtags.join(\" \"),\n    geminiApiKey: geminiApiKey,\n    callbackUrl: callbackUrl\n  }\n}];"
        },
        "id": "parse-hashtags-1769380010487",
        "name": "Parse Hashtags",
        "type": "n8n-nodes-base.code",
        "position": [
          3008,
          -32
        ],
        "typeVersion": 2
      },
      {
        "id": "prepare-post-request-1769980000001",
        "name": "Prepare Post Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2750,
          -32
        ],
        "parameters": {
          "jsCode": "// Sanitize content for JSON serialization\nconst prevData = $input.first().json;\nconst selectedTopic = prevData.selectedTopic || {};\nconst extractedStats = prevData.extractedStats || selectedTopic.extractedStats || {};\nconst teams = prevData.teams || selectedTopic.teams || [];\nconst competition = prevData.competition || selectedTopic.competition || '';\nconst hashtagString = prevData.hashtagString || '#football #soccer #UEFA';\nconst sourceCount = prevData.sourceCount || 1;\nconst keyFacts = prevData.keyFacts || [];\n\n// Sanitize function - remove characters that break JSON\nconst sanitize = (str) => {\n  if (typeof str !== 'string') return String(str || '');\n  return str\n    .replace(/[\\x00-\\x1F\\x7F]/g, ' ')\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\"/g, \"'\")\n    .replace(/\\n/g, ' ')\n    .substring(0, 2000)\n    .trim();\n};\n\n// Build sanitized values\nconst headline = sanitize(selectedTopic.headline || 'Football news');\nconst comprehensiveSummary = sanitize(prevData.comprehensiveSummary || 'Football update');\nconst teamsStr = sanitize(teams.join(', '));\nconst competitionStr = sanitize(competition);\nconst keyFactsStr = sanitize(keyFacts.slice(0, 3).join('; '));\n\n// Build the prompt\nconst promptText = `You are an objective European football journalist creating a comprehensive Facebook post.\n\nTOPIC: ${headline}\nCOMPREHENSIVE SUMMARY: ${comprehensiveSummary}\nTEAMS: ${teamsStr}\nCOMPETITION: ${competitionStr}\nHASHTAGS TO USE: ${hashtagString}\n\nEXTRACTED STATISTICS:\n- Score: ${extractedStats.score || 'not available'}\n- Possession: Home ${extractedStats.possession?.home || '?'}% - Away ${extractedStats.possession?.away || '?'}%\n- Shots: Home ${extractedStats.shots?.home || '?'} - Away ${extractedStats.shots?.away || '?'}\n- Transfer Fee: ${extractedStats.transferFee || 'N/A'}\n- League Position: ${extractedStats.leaguePosition || 'N/A'}\n- Points: ${extractedStats.points || 'N/A'}\n\nKEY FACTS: ${keyFactsStr}\nSOURCE COUNT: ${sourceCount} sources analyzed\n\nCreate an OBJECTIVE journalism-style Facebook post (3-4 paragraphs) that:\n1. LEADS with the most significant statistic or result\n2. Presents facts neutrally without bias toward any team\n3. Includes ALL available statistics naturally in the narrative\n4. Provides context about implications for the league/tournament\n5. Uses measured language - avoid superlatives and hype\n6. MUST end with these EXACT hashtags: ${hashtagString}\n\nReturn ONLY a JSON object with:\n- postContent: the full post text including hashtags\n- sentiment: positive/neutral/negative\n- statsHighlighted: array of stats you included`;\n\n// Build Gemini request body\nconst requestBody = {\n  contents: [{\n    parts: [{\n      text: promptText\n    }]\n  }]\n};\n\nreturn [{\n  json: {\n    geminiRequestBody: requestBody,\n    selectedTopic: selectedTopic,\n    extractedStats: extractedStats,\n    teams: teams,\n    competition: competition,\n    hashtagString: hashtagString,\n    sourceUrls: prevData.sourceUrls || [],\n    sourceCount: sourceCount,\n    sourceLink: prevData.sourceLink || selectedTopic.sourceLink || '',\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}];"
        }
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "BilkoBibitkovApp/1.0"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"Create a complete, informative EVENT SUMMARY sentence for a sports infographic overlay.\\n\\nTOPIC: {{ $json.selectedTopic?.headline }}\\nSCORE: {{ $json.extractedStats?.score || 'N/A' }}\\nTEAMS: {{ $json.selectedTopic?.teams?.join(' vs ') || 'N/A' }}\\nCOMPETITION: {{ $json.selectedTopic?.competition || 'European Football' }}\\nTRANSFER FEE: {{ $json.extractedStats?.transferFee || 'N/A' }}\\nLEAGUE POSITION: {{ $json.extractedStats?.leaguePosition || 'N/A' }}\\nPOINTS: {{ $json.extractedStats?.points || 'N/A' }}\\n\\nCreate an event summary that:\\n1. Is a COMPLETE SENTENCE (15-25 words)\\n2. Includes ALL key facts: teams, scores, competition, context\\n3. Is informative and readable as a standalone statement\\n4. NO generic phrases: 'Game On', 'What A Match', 'Breaking News'\\n\\nGOOD EXAMPLES:\\n- 'Barcelona defeated Real Madrid 3-0 in El Clásico with Lewandowski scoring twice'\\n- 'Manchester City secured the Premier League title with 2 games remaining'\\n- 'Kylian Mbappé completes €180M transfer to Real Madrid on a 5-year contract'\\n\\nBAD EXAMPLES (PROHIBITED):\\n- '2-1 Victory!' (too short, no context)\\n- 'Game On!' (generic, no facts)\\n- 'Top of the Table' (vague, no teams)\\n\\nReturn ONLY JSON: { \\\"eventSummary\\\": \\\"your complete sentence here\\\" }\"\n    }]\n  }]\n}",
          "options": {
            "response": {
              "response": {}
            }
          },
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "name": "Generate Event Summary",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2608,
          112
        ],
        "id": "tagline-gen-1769390960853",
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Build Image Request\").first().json;\n\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const taglineData = JSON.parse(cleaned);\n  return [{\n    json: {\n      eventSummary: taglineData.eventSummary || \"Match Report\",\n      imagePrompt: prevData.imagePrompt,\n      infographicElements: prevData.infographicElements,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: prevData.sourceLink,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  // Generate fallback tagline from stats\n  let fallbackTagline = \"Match Report\";\n  if (prevData.extractedStats?.score) {\n    fallbackTagline = prevData.extractedStats.score + \" Final\";\n  } else if (prevData.extractedStats?.transferFee) {\n    fallbackTagline = prevData.extractedStats.transferFee + \" Deal\";\n  } else if (prevData.extractedStats?.leaguePosition) {\n    fallbackTagline = \"#\" + prevData.extractedStats.leaguePosition + \" Ranking\";\n  }\n  \n  return [{\n    json: {\n      eventSummary: fallbackTagline,\n      imagePrompt: prevData.imagePrompt,\n      infographicElements: prevData.infographicElements,\n      postContent: prevData.postContent,\n      selectedTopic: prevData.selectedTopic,\n      extractedStats: prevData.extractedStats || {},\n      comprehensiveSummary: prevData.comprehensiveSummary,\n      keyFacts: prevData.keyFacts,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      sourceLink: prevData.sourceLink,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Event Summary",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2864,
          112
        ],
        "id": "parse-tagline-1769390960853"
      },
      {
        "id": "brand-image-node-1769619318863",
        "name": "Brand Image",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3580,
          112
        ],
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/images/brand",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ imageBase64: $json.imageDataUri ? $json.imageDataUri.replace(/^data:image\\/[^;]+;base64,/, \"\") : null }) }}",
          "options": {}
        }
      },
      {
        "id": "parse-brand-node-1769619318863",
        "name": "Parse Brand Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3800,
          112
        ],
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Parse Imagen Response\").first().json;\n\n// Our /api/images/brand endpoint returns: { success, brandedImageBase64, ... }\n// NOT Gemini format (candidates[].content.parts[])\nlet brandedImageBase64 = null;\n\nif (input.success && input.brandedImageBase64) {\n  // Direct response from our Replit branding endpoint\n  brandedImageBase64 = input.brandedImageBase64;\n} else if (input?.candidates?.[0]?.content?.parts) {\n  // Fallback: Gemini API format (if we ever switch back)\n  const parts = input.candidates[0].content.parts;\n  const imagePart = parts.find(p => p.inlineData?.mimeType?.startsWith(\"image/\"));\n  if (imagePart && imagePart.inlineData?.data) {\n    brandedImageBase64 = imagePart.inlineData.data;\n  }\n}\n\nreturn [{\n  json: {\n    success: !!brandedImageBase64,\n    brandedImageBase64: brandedImageBase64,\n    brandingError: !brandedImageBase64 ? (input.error || 'No branded image in response') : null,\n    imageDataUri: prevData.imageDataUri,\n    imagePrompt: prevData.imagePrompt,\n    eventSummary: prevData.eventSummary,\n    infographicElements: prevData.infographicElements,\n    postContent: prevData.postContent,\n    selectedTopic: prevData.selectedTopic,\n    extractedStats: prevData.extractedStats || {},\n    comprehensiveSummary: prevData.comprehensiveSummary,\n    keyFacts: prevData.keyFacts,\n    sourceUrls: prevData.sourceUrls,\n    sourceCount: prevData.sourceCount,\n    sourceLink: prevData.sourceLink,\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}];"
        }
      },
      {
        "id": "cc_body_builder",
        "name": "Build Compliance Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1620,
          -32
        ],
        "parameters": {
          "jsCode": "// Build the Gemini API request body for compliance checking\nconst headline = $input.first().json.headline;\nconst people = $input.first().json.people || [];\nconst imageSuggestion = $input.first().json.imageSuggestion;\nconst geminiApiKey = $input.first().json.geminiApiKey;\nconst runIndex = $input.first().json.runIndex;\nconst link = $input.first().json.link;\n\nconst prompt = `You are an AI image compliance expert. Analyze this football topic and create anonymous visual descriptions.\n\nTOPIC: ${headline}\nPEOPLE: ${JSON.stringify(people)}\nIMAGE IDEA: ${imageSuggestion}\n\nFor each person listed, generate an anonymous physical description (height, build, hair, attire) without using their name.\n\nReturn ONLY valid JSON with these fields:\n- compliant: true\n- reason: why its safe for image generation  \n- anonymizedDescriptions: object mapping each person name to their anonymous description\n- safeImagePrompt: the image prompt rewritten with anonymous descriptions`;\n\nreturn {\n  json: {\n    headline,\n    people,\n    imageSuggestion,\n    geminiApiKey,\n    runIndex,\n    link,\n    requestBody: {\n      contents: [{\n        parts: [{ text: prompt }]\n      }]\n    }\n  }\n};\n"
        }
      },
      {
        "id": "gi_body_builder",
        "name": "Build Image Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2006,
          112
        ],
        "parameters": {
          "jsCode": "const prevData = $input.first().json;\nconst selectedTopic = prevData.selectedTopic || {};\nconst extractedStats = prevData.extractedStats || {};\nconst keyFacts = prevData.keyFacts || [];\nconst sourceCount = prevData.sourceCount || 1;\nconst teams = selectedTopic.teams || [];\n\n// WALLPAPER-FIRST DESIGN: Prioritize cinematic scene with minimal overlays\n// Select only 2-3 MOST IMPACTFUL stats (not all of them)\nconst statPriority = [];\n\n// Priority 1: Score (most important for match results)\nif (extractedStats.score) {\n  statPriority.push({\n    type: 'score',\n    value: extractedStats.score,\n    display: extractedStats.score\n  });\n}\n\n// Priority 2: Transfer fee (for transfer news)\nif (extractedStats.transferFee && !extractedStats.score) {\n  statPriority.push({\n    type: 'transfer',\n    value: extractedStats.transferFee,\n    display: extractedStats.transferFee\n  });\n}\n\n// Priority 3: League position (for standings news)\nif (extractedStats.leaguePosition && statPriority.length < 2) {\n  const ordinal = extractedStats.leaguePosition + (['st','nd','rd'][((extractedStats.leaguePosition+90)%100-10)%10-1]||'th');\n  statPriority.push({\n    type: 'position',\n    value: extractedStats.leaguePosition,\n    display: ordinal + ' Place'\n  });\n}\n\n// Priority 4: Possession (visual stat for match)\nif (extractedStats.possession?.home && statPriority.length < 2) {\n  statPriority.push({\n    type: 'possession',\n    value: extractedStats.possession.home,\n    display: extractedStats.possession.home + '% Possession'\n  });\n}\n\n// Priority 5: Points (if league standings)\nif (extractedStats.points && statPriority.length < 2) {\n  statPriority.push({\n    type: 'points',\n    value: extractedStats.points,\n    display: extractedStats.points + ' pts'\n  });\n}\n\n// Allow 1-5 stat overlays based on data richness\n// dataRichness is from Topic Analyst (selectedTopic), not extractedStats\nconst dataRichness = selectedTopic.dataRichness || extractedStats.dataConfidence || 3;\n// REDUCED from 5 to 3 max overlays for cleaner visual aesthetic\n// High dataRichness still gets 2-3 overlays, but never more\nconst maxOverlays = Math.min(3, Math.max(1, Math.ceil(dataRichness / 3)));\nconst selectedStats = statPriority.slice(0, maxOverlays);\n\n// Build team color context\n// Build team logo instruction for image\nconst teamLogos = teams.length > 0\n  ? 'Include stylized logos or emblems representing: ' + teams.join(', ') + '.'\n  : 'Include relevant league/competition branding.';\n\nconst teamColors = teams.length >= 2 \n  ? 'colors inspired by ' + teams[0] + ' and ' + teams[1]\n  : teams.length === 1 \n    ? 'colors inspired by ' + teams[0]\n    : 'deep blue and gold accents';\n\n// Determine scene type based on news category\nlet sceneType = 'epic stadium atmosphere at golden hour';\nif (extractedStats.transferFee) {\n  sceneType = 'dramatic press conference lighting with stadium silhouette in background';\n} else if (extractedStats.leaguePosition) {\n  sceneType = 'trophy room with championship memorabilia, dramatic spotlight';\n} else if (extractedStats.score) {\n  sceneType = 'packed stadium celebrating, flares and confetti, wide cinematic angle';\n}\n\n// WALLPAPER-FIRST prompt structure\nlet fullPrompt = 'Create a CINEMATIC DESKTOP WALLPAPER image (16:9 aspect ratio). ';\nfullPrompt += 'Primary focus: ' + sceneType + '. ';\nfullPrompt += 'Style: High-end sports broadcast quality, dramatic lighting, ' + teamColors + '. ';\nfullPrompt += 'Composition: 70% atmospheric scene, 30% clean negative space for optional text overlay. ';\nfullPrompt += 'Aesthetic: Premium, immersive, like a movie poster or AAA game cover. ';\n\n// Add MINIMAL stat overlays (2 max)\nif (selectedStats.length > 0) {\n  const overlays = selectedStats.map(s => {\n    if (s.type === 'score') {\n      return 'SCORE: \"' + s.display + '\" - large, elegant typography in lower third';\n    } else if (s.type === 'transfer') {\n      return 'FEE BADGE: \"' + s.display + '\" - gold accent, corner placement';\n    } else if (s.type === 'position') {\n      return 'RANK: \"' + s.display + '\" - subtle, integrated into scene';\n    } else if (s.type === 'possession') {\n      return 'STAT: \"' + s.display + '\" - thin bar graphic, bottom edge';\n    } else if (s.type === 'points') {\n      return 'POINTS: \"' + s.display + '\" - small badge, corner';\n    }\n    return '';\n  }).filter(Boolean);\n  \n  fullPrompt += 'Minimal overlays: ' + overlays.join('. ') + '. ';\n} else {\n  fullPrompt += 'No text overlays - pure atmospheric image. ';\n}\n\nfullPrompt += 'CRITICAL: NO faces, NO real people, NO player likenesses. Focus on atmosphere, stadium, crowd energy, abstract team elements. ';\nfullPrompt += 'Quality: 4K desktop wallpaper, sharp details, professional color grading.';\n\nconst requestBody = {\n  contents: [{\n    parts: [{\n      text: fullPrompt\n    }]\n  }]\n};\n\nreturn [{\n  json: {\n    requestBody,\n    imagePrompt: fullPrompt,\n    selectedStats: selectedStats,\n    sceneType: sceneType,\n    postContent: prevData.postContent,\n    selectedTopic: prevData.selectedTopic,\n    extractedStats: extractedStats,\n    comprehensiveSummary: prevData.comprehensiveSummary,\n    keyFacts: keyFacts,\n    sourceUrls: prevData.sourceUrls,\n    sourceCount: sourceCount,\n    sourceLink: prevData.sourceLink,\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}];"
        }
      },
      {
        "id": "fetch-article-content-1769975476415",
        "name": "Fetch Article Content",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2600,
          -150
        ],
        "parameters": {
          "method": "GET",
          "url": "={{ $json.selectedTopic.sourceLink }}",
          "options": {
            "redirect": {
              "redirect": {
                "followRedirects": true,
                "maxRedirects": 5
              }
            },
            "response": {
              "response": {
                "responseFormat": "text"
              }
            },
            "timeout": 15000
          }
        },
        "retryOnFail": true,
        "maxTries": 2,
        "waitBetweenTries": 2000
      },
      {
        "id": "prepare-stats-request-1769980000000",
        "name": "Prepare Stats Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2675,
          -150
        ],
        "parameters": {
          "jsCode": "// Sanitize article content to prevent JSON serialization issues\nconst articleData = $('Fetch Article Content').first().json;\nconst aggregateData = $('Aggregate Compliant Topics').first().json;\nconst selectedTopic = aggregateData.selectedTopic || {};\n\n// Get raw content and sanitize it\nlet rawContent = articleData?.data || 'No content available';\n\n// Remove problematic characters and limit length\nrawContent = rawContent\n  .replace(/[\\x00-\\x1F\\x7F]/g, ' ')  // Remove control characters\n  .replace(/\\\\n/g, ' ')  // Replace escaped newlines\n  .replace(/\\n/g, ' ')   // Replace actual newlines\n  .replace(/\\r/g, ' ')   // Replace carriage returns\n  .replace(/\\t/g, ' ')   // Replace tabs\n  .replace(/\\\\/g, ' ')   // Remove backslashes\n  .replace(/\"/g, \"'\")    // Replace double quotes with single\n  .substring(0, 6000)    // Limit content length\n  .trim();\n\n// Build the prompt text\nconst promptText = `Extract SPECIFIC STATISTICS from this football article. Look for:\n\n1. MATCH SCORES (e.g., 3-0, 2-1)\n2. POSSESSION PERCENTAGES\n3. SHOT COUNTS\n4. TRANSFER FEES (in millions)\n5. LEAGUE STANDINGS/POINTS\n6. GOAL SCORERS (without names, just counts)\n7. ANY OTHER NUMERICAL DATA\n\nARTICLE CONTENT:\n${rawContent}\n\nHEADLINE: ${selectedTopic.headline || 'No headline'}\n\nReturn ONLY valid JSON:\n{\n  \"score\": \"3-0\" or null,\n  \"homeTeam\": \"Team A\" or null,\n  \"awayTeam\": \"Team B\" or null,\n  \"possession\": { \"home\": 65, \"away\": 35 } or null,\n  \"shots\": { \"home\": 15, \"away\": 8 } or null,\n  \"transferFee\": \"80M\" or null,\n  \"leaguePosition\": 1 or null,\n  \"points\": 45 or null,\n  \"goalCount\": 3 or null,\n  \"keyStatistic\": \"most important number/stat found\",\n  \"dataRichness\": 1-10 (how much real data found)\n}`;\n\n// Build the Gemini request body\nconst requestBody = {\n  contents: [{\n    parts: [{\n      text: promptText\n    }]\n  }]\n};\n\nreturn [{\n  json: {\n    geminiRequestBody: requestBody,\n    selectedTopic: selectedTopic,\n    geminiApiKey: aggregateData.geminiApiKey,\n    callbackUrl: aggregateData.callbackUrl\n  }\n}];"
        }
      },
      {
        "id": "extract-statistics-1769975476415",
        "name": "Extract Statistics",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2750,
          -150
        ],
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (compatible; BilkoBibitkov/1.0)"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json.geminiRequestBody) }}",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "id": "parse-statistics-1769975476415",
        "name": "Parse Statistics",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2900,
          -150
        ],
        "parameters": {
          "jsCode": "const geminiResponse = $input.first().json;\nconst aggregateData = $(\"Aggregate Compliant Topics\").first().json;\nconst geminiApiKey = aggregateData.geminiApiKey;\nconst callbackUrl = aggregateData.callbackUrl;\nconst selectedTopic = aggregateData.selectedTopic;\n\nlet extractedStats = {\n  score: null,\n  homeTeam: null,\n  awayTeam: null,\n  possession: null,\n  shots: null,\n  transferFee: null,\n  leaguePosition: null,\n  points: null,\n  goalCount: null,\n  keyStatistic: null,\n  dataRichness: 1\n};\n\ntry {\n  const candidates = geminiResponse.candidates || [];\n  if (candidates.length > 0) {\n    let text = candidates[0].content?.parts?.[0]?.text || \"\";\n    text = text.replace(/```json\\n?/g, \"\").replace(/```/g, \"\").trim();\n    const parsed = JSON.parse(text);\n    extractedStats = { ...extractedStats, ...parsed };\n  }\n} catch (e) {\n  // Keep defaults\n}\n\n// Build enhanced tagline based on extracted data\nlet enhancedTagline = selectedTopic.headline;\nif (extractedStats.score && extractedStats.homeTeam && extractedStats.awayTeam) {\n  enhancedTagline = extractedStats.homeTeam + \" \" + extractedStats.score + \" \" + extractedStats.awayTeam;\n} else if (extractedStats.score) {\n  enhancedTagline = selectedTopic.teams?.[0] + \" \" + extractedStats.score + \" \" + (selectedTopic.teams?.[1] || \"\");\n} else if (extractedStats.transferFee) {\n  enhancedTagline = extractedStats.transferFee + \" Transfer Complete\";\n} else if (extractedStats.leaguePosition && extractedStats.points) {\n  enhancedTagline = selectedTopic.teams?.[0] + \" #\" + extractedStats.leaguePosition + \" (\" + extractedStats.points + \" pts)\";\n}\n\nreturn [{\n  json: {\n    selectedTopic: {\n      ...selectedTopic,\n      extractedStats: extractedStats,\n      enhancedTagline: enhancedTagline.trim(),\n      hasRealData: extractedStats.dataRichness >= 5\n    },\n    sourceLink: selectedTopic.sourceLink || \"\",\n    anonymizedDescriptions: selectedTopic.anonymizedDescriptions || {},\n    geminiApiKey: geminiApiKey,\n    callbackUrl: callbackUrl\n  }\n}];"
        }
      },
      {
        "parameters": {
          "jsCode": "const prevData = $input.first().json;\nconst selectedTopic = prevData.selectedTopic || {};\nconst headline = selectedTopic.headline || '';\nconst teams = selectedTopic.teams || [];\n\n// Build search query from topic\nconst searchTerms = [];\nif (teams.length > 0) {\n  searchTerms.push(...teams.slice(0, 2));\n}\n\n// Extract key words from headline\nconst keyWords = headline\n  .replace(/[^a-zA-Z0-9\\s]/g, '')\n  .split(/\\s+/)\n  .filter(w => w.length > 4 && !['about', 'after', 'before', 'their', 'there', 'where', 'which', 'would', 'could', 'should'].includes(w.toLowerCase()))\n  .slice(0, 3);\n\nsearchTerms.push(...keyWords);\nconst searchQuery = searchTerms.join(' ');\n\n// Build Google News RSS URL for topic-specific search\nconst encodedQuery = encodeURIComponent(searchQuery + ' football');\nconst searchUrl = 'https://news.google.com/rss/search?q=' + encodedQuery + '&hl=en-US&gl=US&ceid=US:en';\n\nreturn [{\n  json: {\n    ...prevData,\n    searchQuery: searchQuery,\n    searchUrl: searchUrl,\n    primarySource: {\n      url: selectedTopic.sourceLink || '',\n      headline: selectedTopic.sourceHeadline || headline\n    }\n  }\n}];"
        },
        "name": "Build Search Query",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1900,
          -200
        ],
        "id": "search-query-builder-001"
      },
      {
        "parameters": {
          "url": "={{ $json.searchUrl }}",
          "options": {}
        },
        "name": "Search Related Sources",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2100,
          -200
        ],
        "id": "search-related-sources-001"
      },
      {
        "parameters": {
          "options": {}
        },
        "name": "Parse Search Results",
        "type": "n8n-nodes-base.xml",
        "typeVersion": 1,
        "position": [
          2300,
          -200
        ],
        "id": "parse-search-results-001"
      },
      {
        "parameters": {
          "jsCode": "const rssData = $input.first().json;\nconst prevData = $(\"Build Search Query\").first().json;\nconst primarySource = prevData.primarySource || {};\n\n// Extract articles from RSS\nconst items = rssData?.rss?.channel?.item || [];\n\n// Collect up to 5 sources (including primary)\nconst sources = [];\n\n// Add primary source first\nif (primarySource.url) {\n  sources.push({\n    url: primarySource.url,\n    headline: primarySource.headline,\n    isPrimary: true\n  });\n}\n\n// Add related sources (skip duplicates)\nconst seenUrls = new Set([primarySource.url?.toLowerCase()]);\n\nfor (const item of items.slice(0, 10)) {\n  if (sources.length >= 5) break;\n  \n  const link = item.link || '';\n  const title = item.title || '';\n  \n  // Skip if duplicate or same domain as primary\n  if (seenUrls.has(link.toLowerCase())) continue;\n  \n  // Skip Google News redirect wrapper - extract actual URL\n  let actualUrl = link;\n  if (link.includes('news.google.com')) {\n    // Keep the redirect link as-is for now\n    actualUrl = link;\n  }\n  \n  seenUrls.add(actualUrl.toLowerCase());\n  sources.push({\n    url: actualUrl,\n    headline: title,\n    isPrimary: false\n  });\n}\n\nreturn [{\n  json: {\n    ...prevData,\n    sources: sources,\n    sourceCount: sources.length\n  }\n}];"
        },
        "name": "Collect Sources",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2500,
          -200
        ],
        "id": "collect-sources-001"
      },
      {
        "parameters": {
          "jsCode": "const prevData = $input.first().json;\nconst sources = prevData.sources || [];\n\n// Create HTTP requests for each source\nconst requests = sources.map((source, index) => ({\n  json: {\n    sourceIndex: index,\n    sourceUrl: source.url,\n    sourceHeadline: source.headline,\n    isPrimary: source.isPrimary,\n    allSources: sources,\n    selectedTopic: prevData.selectedTopic,\n    geminiApiKey: prevData.geminiApiKey,\n    callbackUrl: prevData.callbackUrl\n  }\n}));\n\nreturn requests;"
        },
        "name": "Split Sources",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2700,
          -200
        ],
        "id": "split-sources-001"
      },
      {
        "parameters": {
          "url": "={{ $json.sourceUrl }}",
          "options": {
            "response": {
              "response": {
                "fullResponse": false,
                "responseFormat": "text"
              }
            },
            "timeout": 10000
          }
        },
        "name": "Fetch Source Content",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2900,
          -200
        ],
        "id": "fetch-source-content-001",
        "continueOnFail": true
      },
      {
        "parameters": {
          "jsCode": "const htmlContent = $input.first().json.data || $input.first().json || '';\nconst prevItem = $input.first().json;\nconst sourceIndex = prevItem.sourceIndex ?? 0;\nconst sourceUrl = prevItem.sourceUrl || '';\nconst sourceHeadline = prevItem.sourceHeadline || '';\nconst isPrimary = prevItem.isPrimary || false;\nconst allSources = prevItem.allSources || [];\n\n// Extract text from HTML (basic extraction)\nlet text = '';\nif (typeof htmlContent === 'string') {\n  // Remove scripts and styles\n  text = htmlContent\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, '')\n    .replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, '')\n    .replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, '')\n    .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/\\s+/g, ' ')\n    .trim()\n    .slice(0, 8000);\n}\n\nreturn [{\n  json: {\n    sourceIndex,\n    sourceUrl,\n    sourceHeadline,\n    isPrimary,\n    content: text,\n    allSources,\n    selectedTopic: prevItem.selectedTopic,\n    geminiApiKey: prevItem.geminiApiKey,\n    callbackUrl: prevItem.callbackUrl\n  }\n}];"
        },
        "name": "Parse Source Content",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3100,
          -200
        ],
        "id": "parse-source-content-001"
      },
      {
        "parameters": {
          "aggregate": "aggregateAllItemData",
          "options": {}
        },
        "name": "Aggregate Sources",
        "type": "n8n-nodes-base.aggregate",
        "typeVersion": 1,
        "position": [
          3300,
          -200
        ],
        "id": "aggregate-sources-001"
      },
      {
        "parameters": {
          "jsCode": "const items = $input.first().json.data || [];\nconst firstItem = items[0] || {};\nconst allSources = firstItem.allSources || [];\nconst selectedTopic = firstItem.selectedTopic || {};\n\n// Build combined content\nconst articlesText = items\n  .sort((a, b) => (b.isPrimary ? 1 : 0) - (a.isPrimary ? 1 : 0))\n  .map((item, idx) => {\n    const label = item.isPrimary ? '[PRIMARY SOURCE]' : '[SOURCE ' + (idx + 1) + ']';\n    return label + '\\nHeadline: ' + item.sourceHeadline + '\\nContent: ' + (item.content || 'No content available').slice(0, 3000);\n  })\n  .join('\\n\\n---\\n\\n');\n\n// Build source URLs for citations\nconst sourceUrls = allSources.map((s, i) => ({\n  index: i + 1,\n  url: s.url,\n  headline: s.headline\n}));\n\nreturn [{\n  json: {\n    articlesText,\n    sourceUrls,\n    sourceCount: items.length,\n    selectedTopic,\n    geminiApiKey: firstItem.geminiApiKey,\n    callbackUrl: firstItem.callbackUrl\n  }\n}];"
        },
        "name": "Merge All Content",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3500,
          -200
        ],
        "id": "merge-all-content-001"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "x-goog-api-key",
                "value": "={{ $json.geminiApiKey }}"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are an objective football journalist synthesizing multiple sources into a comprehensive summary.\\n\\nARTICLES:\\n{{ $json.articlesText }}\\n\\nAnalyze ALL sources and extract:\\n\\nReturn ONLY a JSON object with:\\n{\\n  \\\"summary\\\": \\\"2-3 paragraph objective summary synthesizing all sources (NO player names, focus on facts and numbers)\\\",\\n  \\\"stats\\\": {\\n    \\\"score\\\": \\\"final score if match (e.g. 2-1) or null\\\",\\n    \\\"possession\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"shots\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"shotsOnTarget\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"xG\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"corners\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"fouls\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"yellowCards\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"redCards\\\": { \\\"home\\\": number or null, \\\"away\\\": number or null },\\n    \\\"transferFee\\\": \\\"transfer amount if applicable or null\\\",\\n    \\\"leaguePosition\\\": number or null,\\n    \\\"points\\\": number or null,\\n    \\\"goalDifference\\\": number or null,\\n    \\\"winStreak\\\": number or null,\\n    \\\"cleanSheets\\\": number or null,\\n    \\\"otherStats\\\": [\\\"any other significant numbers found\\\"]\\n  },\\n  \\\"teams\\\": [\\\"team names mentioned\\\"],\\n  \\\"competition\\\": \\\"league/tournament name\\\",\\n  \\\"keyFacts\\\": [\\\"3-5 bullet point facts\\\"],\\n  \\\"dataConfidence\\\": \\\"high/medium/low - based on source agreement\\\"\\n}\\n\\nBe thorough - extract EVERY statistic mentioned across ALL sources. Prioritize numbers and objective facts.\\\"\\n    }]\\n  }]\\n}\"\n    }",
          "options": {},
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth"
        },
        "name": "Comprehensive Summary",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          3700,
          -200
        ],
        "id": "comprehensive-summary-001",
        "credentials": {
          "httpHeaderAuth": {
            "id": "K9oPxIngg8rE26T6",
            "name": "Header Auth account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const input = $input.first().json;\nconst prevData = $(\"Merge All Content\").first().json;\n\nconst text = input?.candidates?.[0]?.content?.parts?.[0]?.text || \"{}\";\nconst cleaned = text.replace(/^```[a-zA-Z]*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\");\n\ntry {\n  const summary = JSON.parse(cleaned);\n  return [{\n    json: {\n      comprehensiveSummary: summary.summary,\n      extractedStats: summary.stats,\n      teams: summary.teams,\n      competition: summary.competition,\n      keyFacts: summary.keyFacts,\n      dataConfidence: summary.dataConfidence,\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      selectedTopic: prevData.selectedTopic,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      comprehensiveSummary: prevData.selectedTopic?.headline || \"Football news update\",\n      extractedStats: {},\n      teams: prevData.selectedTopic?.teams || [],\n      competition: \"\",\n      keyFacts: [],\n      dataConfidence: \"low\",\n      sourceUrls: prevData.sourceUrls,\n      sourceCount: prevData.sourceCount,\n      selectedTopic: prevData.selectedTopic,\n      geminiApiKey: prevData.geminiApiKey,\n      callbackUrl: prevData.callbackUrl,\n      parseError: e.message\n    }\n  }];\n}"
        },
        "name": "Parse Summary",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3900,
          -200
        ],
        "id": "parse-summary-001"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"comprehensive-summary\",\n  \"stepIndex\": 5,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"summary\": {{ JSON.stringify($json.comprehensiveSummary || \"\") }},\n    \"stats\": {{ JSON.stringify($json.extractedStats || {}) }},\n    \"teams\": {{ JSON.stringify($json.teams || []) }},\n    \"competition\": {{ JSON.stringify($json.competition || \"\") }},\n    \"keyFacts\": {{ JSON.stringify($json.keyFacts || []) }},\n    \"sourceCount\": {{ $json.sourceCount || 0 }},\n    \"dataConfidence\": {{ JSON.stringify($json.dataConfidence || \"low\") }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
          "options": {}
        },
        "name": "Callback Summary",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          4000,
          -300
        ],
        "id": "callback-summary-001",
        "continueOnFail": true
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://bilkobibitkov.replit.app/api/workflows/callback",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"workflowId\": \"european-football-daily\",\n  \"step\": \"eventSummary-generated\",\n  \"stepIndex\": 7,\n  \"traceId\": \"{{ $('Webhook').first().json.body.traceId || 'trace_' + $execution.id }}\",\n  \"output\": {\n    \"eventSummary\": {{ JSON.stringify($json.eventSummary || \"\") }},\n    \"imagePrompt\": {{ JSON.stringify($json.imagePrompt || \"\").substring(0, 500) }},\n    \"selectedStats\": {{ JSON.stringify($json.selectedStats || []) }},\n    \"sceneType\": {{ JSON.stringify($json.sceneType || \"\") }}\n  },\n  \"executionId\": \"{{ $execution.id }}\"\n}",
          "options": {}
        },
        "name": "Callback Event Summary",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          2950,
          250
        ],
        "id": "callback-tagline-001",
        "continueOnFail": true
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Fetch RSS",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch RSS": {
        "main": [
          [
            {
              "node": "Parse XML",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse XML": {
        "main": [
          [
            {
              "node": "Extract Articles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Articles": {
        "main": [
          [
            {
              "node": "Topic Analyst",
              "type": "main",
              "index": 0
            },
            {
              "node": "Callback Articles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Post": {
        "main": [
          [
            {
              "node": "Parse Post",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Image": {
        "main": [
          [
            {
              "node": "Parse Image Prompt",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Final Output": {
        "main": [
          [
            {
              "node": "Callback Final",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Callback Final": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call Imagen API": {
        "main": [
          [
            {
              "node": "Parse Imagen Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Imagen Response": {
        "main": [
          [
            {
              "node": "Brand Image",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Topic Analyst": {
        "main": [
          [
            {
              "node": "Parse Topic Analysis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Topic Analysis": {
        "main": [
          [
            {
              "node": "Build Compliance Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Compliance Checker": {
        "main": [
          [
            {
              "node": "Parse Compliance Check",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Compliance Check": {
        "main": [
          [
            {
              "node": "Aggregate Compliant Topics",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Aggregate Compliant Topics": {
        "main": [
          [
            {
              "node": "Fetch Article Content",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Post": {
        "main": [
          [
            {
              "node": "Build Image Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Image Prompt": {
        "main": [
          [
            {
              "node": "Generate Event Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Hashtag Researcher": {
        "main": [
          [
            {
              "node": "Parse Hashtags",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Hashtags": {
        "main": [
          [
            {
              "node": "Prepare Post Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Post Request": {
        "main": [
          [
            {
              "node": "Generate Post",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Generate Event Summary": {
        "main": [
          [
            {
              "node": "Parse Event Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Event Summary": {
        "main": [
          [
            {
              "node": "Call Imagen API",
              "type": "main",
              "index": 0
            },
            {
              "node": "Callback Event Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Brand Image": {
        "main": [
          [
            {
              "node": "Parse Brand Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Brand Response": {
        "main": [
          [
            {
              "node": "Build Final Output",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Compliance Request": {
        "main": [
          [
            {
              "node": "Compliance Checker",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Image Request": {
        "main": [
          [
            {
              "node": "Generate Image",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Article Content": {
        "main": [
          [
            {
              "node": "Prepare Stats Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Stats Request": {
        "main": [
          [
            {
              "node": "Extract Statistics",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Statistics": {
        "main": [
          [
            {
              "node": "Parse Statistics",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Statistics": {
        "main": [
          [
            {
              "node": "Hashtag Researcher",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Search Query": {
        "main": [
          [
            {
              "node": "Search Related Sources",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Search Related Sources": {
        "main": [
          [
            {
              "node": "Parse Search Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Search Results": {
        "main": [
          [
            {
              "node": "Collect Sources",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Collect Sources": {
        "main": [
          [
            {
              "node": "Split Sources",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Split Sources": {
        "main": [
          [
            {
              "node": "Fetch Source Content",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Source Content": {
        "main": [
          [
            {
              "node": "Parse Source Content",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Source Content": {
        "main": [
          [
            {
              "node": "Aggregate Sources",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Aggregate Sources": {
        "main": [
          [
            {
              "node": "Merge All Content",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge All Content": {
        "main": [
          [
            {
              "node": "Comprehensive Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Comprehensive Summary": {
        "main": [
          [
            {
              "node": "Parse Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Summary": {
        "main": [
          [
            {
              "node": "Hashtag Researcher",
              "type": "main",
              "index": 0
            },
            {
              "node": "Callback Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Bilko Bibitkov",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-02T04:57:59.832Z",
        "id": 187,
        "workflowId": "oV6WGX5uBeTZ9tRa",
        "versionId": "220bc091-4602-4a82-9f94-38bf6a4a70b0",
        "event": "activated",
        "userId": "80f5768f-36e3-4197-9886-2f8e29df41d7"
      }
    ]
  }
}